\begin{section}{Revisão Teórica}
\label{sec:rev_th}
% [IEEE'14] Implementation of vision based intelligent home automation and security system
% [IEEE'11] Designing Android Applications with both Online and Offline Voice Control of Household Devices
% [IEEE'10] Smart Home Control System for the disabled using the head and the mouth movement (CHINESE)
% [IJERA'15] Wi-Fi and Android Based Smart Home Automation for People with Disabilities (UNAUTHORIZED)
 
Como o iOS e o Android foram lançados, respectivamente, em 2007 e 2008, e a
ascensão dos \textit{smartphones} é relativamente recente, a ideia de tornar
acessível o controle de equipamentos eletrônicos somente começou
a revelar resultados concretos a partir de 2010.
Em~\cite{Barrena11}, o decodificador PocketSphinx foi embarcado em um
\textit{smartphone} Android para que este pudesse controlar aparelhos domésticos
através da interface de voz. O resultado do reconhecedor era enviado para placa 
SparkFun IOIO Board, a qual, estando fisicamente conectada ao controle de uma TV, 
acionava um determinado comando. A justificativa do trabalho era 
ajudar pessoas afetadas com tetraplegia a serem mais independentes; os testes 
avaliaram o desempenho de decodificadores embarcados e distribuídos.
Já em~\cite{Sefat14}, um sistema inteligente de segurança foi implementado em 
uma BeagleBone Black, a qual utilizava a biblioteca OpenCV para contar quantos 
indivíduos encontravam-se próximo à entrada do ambiente a ser vigiado. Um módulo
de reconhecimento de fala, também basedo no PocketSphinx, foi utilizado para
receber comandos, enquanto o \textit{software} eSpeak foi encarregado 
de prover as respostas dadas ao usuário via voz sintetizada. Um aparelho
celular qualquer poderia se comunicar com o sistema via SMS graças à adição de
um módulo GSM à BBB. A desvantagem é que, apesar de o controle não ter de ser
executado necessariamente por um \textit{smartphone}, os comandos de voz não
poderiam ser dados diretamente do aparelho móvel, e sim pessoal e diretamente ao
microcomputador, o qual possuía um microfone conectado à porta USB.

\subsection{Reconhecimento e Síntese de Voz}
Os fundamentos do reconhecimento automático de voz, assim como os da síntese de
voz, são descritos com bastante detalhes em~\cite{Huang01}. A arquitetura mais
geral e aceita na literatura é mostrada na Figura~\ref{fig:asr_sch}. Vale
salientar que, ao invés do uso de modelos mais gerais, que descrevem a maior
parte de uma linguagem, serão utilizadas gramáticas livres de contexto, as quais
limitam o vocabulário utilizado a apenas um conjunto de sentenças possíveis,
escolhidas pelo desenvolvedor do sistema. A construção do dicionário fonético
para PT\_BR dar-se-á através do \textit{software} descrito em~\cite{Siravenha08}; 
o tutorial para o treino do modelo acústico encontra-se disponível na página do
projeto Voxforge~\cite{voxforge}, bem como no capítulo 3 do livro do
HTK~\cite[p.~22--42]{Young00} (lembrando que o modelo acústico utilizado também
está disponível na página do FalaBrasil); a gramática reconhecida pelo Julius é
criada manualmente de acordo com o descrito na página oficial~\cite{juliussite}.
Instruções de configuração e utilização do Julius encontram-se na documentação
oficial~\cite{Lee09}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.65\textwidth]{Figures/asr_sch}
	\caption{Esquemático de um sistema ASR}
	\label{fig:asr_sch}
\end{figure}

% http://andicelabs.com/2014/03/usb-audio-beaglebone/
Como saída analógica do sistema TTS, a voz sintetizada deve ser reproduzida por
um dispositivo externo à BeagleBone, já que esta não possui alto-falantes
próprios. Como visto em~\cite{andicelabs}, o dispositivo primário de saída de
áudio é o HDMI, o qual pode ser desabilitado mediante modificações
em parâmetros do \textit{kernel}. Feito isso, o USB, que é o dispositivo secundário, se
torna o principal, fazendo com que a solução mais simples seja plugar um 
alto-falante (\textit{speaker}) na porta USB.
Na página oficial do eSpeak, um arquivo de cabeçalho (\textit{header}) permite a
utilização de uma API em C/C++, a qual facilita o acesso aos módulos do 
\textit{software} que permitem que a BBB ``fale''~\cite{eSpeak}.

%% http://arduino.cc/en/Tutorial/SimpleAudioPlayer
%% http://www.instructables.com/id/Simple-Wav-Player-Using-Arduino/?lang=pt&ALLSTEPS
%% http://forum.arduino.cc/index.php?topic=49654.0 -- can arduino talk without shield?
%% http://www.instructables.com/id/Twitter-Enabled-Text-to-Speech/
%Links úteis podem ser encontrados em~\cite{arduino_player}
%e~\cite{instructables_player}, os quais ensinam o passo-a-passo para o projeto e
%construção de um circuito amplificador. 

\subsection{Comparação entre Plataformas}
A escolha da plataforma foi fundamental para a esquematização do projeto.
Arduino, Raspberry Pi e BeagleBone Black foram as três principais opções a
serem escolhidas. Diversos tutoriais de comparação entre as plataformas foram
consultados e estão disponíveis na Internet~\cite{mhl,randomnerd,makezine}.
O Arduino, apesar de ser uma ferramenta flexível e com grande capacidade de
interfaceamento com uma vasta quantidade de dispositivos, é uma plataforma
simples, recomendada para projetos de menor porte. O microcontrolador, que pode 
ser programado em C, torna-se muito limitado quando o projeto requer um servidor
estável e relativamente potente.
Já o Raspberry Pi, por ser bastante completo, enquadra-se no conceito de 
mini computador, sendo necessário a instalação de um sistema operacional. Todo 
o seu armazenamento é fornecido por um cartão SD, além de ser possível
conectá-lo à Internet através de um conector Ethernet. O Raspberry Pi possui 
ainda uma interface de saída HDMI e é bastante útil para aplicações gráficas.

\begin{table}[!h]
\centering
\caption{Comparação entre as três principais plataformas}
\label{comparison}
\begin{tabular}{c|c c c}
\hline
				& Arduino UNO & BeagleBone Black & Raspberry Pi \\
\hline
Chip			& -          & TI AM3359              & BCM2835 \\
CPU				& ATMega328  & ARM Cortex-A8          & ARM1176JZ-F \\
CPU Freq.		& 16 MHz     & 1 GHz                  & 700 MHz \\
GPU				& -          & PowerVR SGX530         & Dual Core VideoCore IV \\
Memória. RAM	& 2 kB SRAM  & 512 MB DDR3            & 512 MB SDRAM \\
Armaz. Flash	& 32 kB      & 2 GB eMMC, MicroSD     & SD, MMC, SDIO card slot \\
Pinos			& 14         & 65                     & 8 \\
Video			& -          & mini HDMI              & HDMI \\
Sistema Op.		& -          & Linux                  & Linux \\
Amperagem		& 42 mA      & 210-460 mA             & 150-350~mA \\
Voltagem		& 7-12 V     & 5 V                    & 5 V \\
USB				& -          & 1 Host, 1 Mini Client  & 2 Hosts, 1 Micro Power\\
Ethernet		& -          & 1 10/100 Mbps          & 1 10/100 Mbps \\
\hline
\end{tabular}
\end{table}

A BeagleBone Black é comparável ao Raspberry Pi. Entretanto, por ter mais pinos
(GPIO) e um processador mais poderoso, a plataforma é uma escolha óbvia para
projetos mais elaborados. Além de possuir diversas opções de conexão, a
BBB une a flexibilidade de interfaceamento do Arduino com a capacidade
de processamento rápido do Raspberry Pi. Apesar da desvantagem no preço, não
restaram muitas dúvidas no momento da escolha dessa plataforma para o projeto.
Uma comparação entre os principais parâmetros dos três equipamentos é dada na
Tabela~\ref{comparison}.

% Thiago: LIRC

\subsection{Protocolos de Comunicação via Luz Infravermelha}
O funcionamento de controles remotos, com ênfase nos baseados em luz
infravermelha para televisores, é explicado de de forma clara e detalhada em
diversos tutoriais para ``curiosos'' disponíveis na Internet, como os da revista
Mundo Estranho~\cite{mundoestranho} e do blog \textit{How Stuff Works?} da
UOL~\cite{uol_hsw}. Atualmente, a maioria dos aparelhos eletrônicos recebe
informação através de sensores infravermelhos localizados em painéis frontais.
Entretanto, devido à interferência que surge com a vasta transferência de
informação via IR, a comunicação entre o controle remoto e a
televisão ocorre geralmente em 4 passos: um comando \textit{start} inicia a
transferência, seguido dos bits do comando específico (como aumentar o volume,
por exemplo) e do endereço do aparelho. Por fim, um comando de \textit{stop}
encerra o envio de bits. Dessa forma, a chance de a informação ser reconhecida
por mais de um aparelho é baixa (salvo o caso de serem dois equipamentos do
mesmo tipo e da mesma empresa).

Uma das grandes dificuldades relacionadas ao controle de equipamentos
eletrônicos é que os 4 passos acima são apenas uma forma genérica de
descrever a comunicação, ou seja, cada empresa praticamente segue o seu próprio
padrão para estabelecer a comunicação entre os dispositivos: o número, a ordem e
o significado dos bits é variado, a modulação e codificação usada são diferentes
e a frequência dos pulsos pode oscilar entre 32~kHz e 42~kHz, chegando a 50~kHz
em determinados aparelhos mais modernos. Além disso, tão rara quanto o
seguimento de uma comunicação IR padronizada é a disponibilização de
documentação pelos fabricantes, que também é bastante escassa. 

Neste trabalho, serão detalhados protocolos de duas fabricantes: RC-6 e sua 
versão pioneira RC-5, ambos da Philips; e o protocolo utilizado pela Samsung. 

\subsubsection{O Protocolo da Philips: RC-5 e RC-6}
A Philips utiliza seu próprio protocolo de comunicação, chamado RC-5. A última
documentação foi liberada em 1992, quando ainda não existiam muitos dos
equipamentos eletrônicos atuais, como \textit{home theaters} ou DVDs. 

\begin{figure}[!h]
	\centering
	\includegraphics[width=.88\textwidth]{Figures/sch_rc5}
	\caption{Esquemático do protocolo RC-5 da Philips.}
	\label{fig:rc5}
\end{figure}

Nesse padrão, os bits são codificados de acordo com o código de Manchester, onde
cada bit, transmitido dentro de um período fixo, é representado por uma
transição \textit{high-to-low} (0) ou \textit{low-to-high} (1). Esses padrões de
dados são obtidos através de uma operação do tipo XOR (OU-Exclusivo) realizada
entre o clock do dispositivo e o dado propriamente dito~\cite{rc5}.

A Figura~\ref{fig:rc5} mostra a informação referente ao comando ``diminuir
volume'' contida num vetor de 14 bits. Os 11 últimos bits definem o endereço do
aparelho de destino e o comando em si. Pode-se observar que qualquer bit é
representado por duas partes, sendo uma metade em nível baixo e a outra, em
nível alto. Cada nível ocorre num intervalo de 32 períodos. O protocolo utiliza 
a modulação por largura de pulsos (\textit{pulse width modulation} ou PWM). O 
nível alto é gerado por um PWM de \textit{duty cycle} que varia entre 25\% e
33\% do período do pulso. Essa percentagem define o tempo em que o IR LED
permanece aceso, ou seja, no nível alto, o IR LED permanece ligado por período
de $0,25\times1/36000~s$ e desligado por $0,75\times1/36000~s$, sendo o processo
repetido 32 vezes. A economia de energia é mostrada como justificativa para
explicar o motivo de o led piscar ao invés de se manter aceso por 100\% do
período do pulso.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.65\textwidth]{Figures/rc6}
	\caption{Esquemático do protocolo RC-6 da Philips.}
	\label{fig:rc6}
\end{figure}

Os aparelhos mais novos já implementam a versão atualizada desse protocolo,
chamado de RC-6. Embora a Philips não tenha disponibilizado qualquer
documentação sobre este protocolo, há fóruns na Internet que, através da
aplicação de engenharia reversa, conseguem descrever o padrão utilizado na
construção do sinal. Pela Figura~\ref{fig:rc6}, é fácil notar que a quantidade
de bits carregada pelo sinal (em comparação com o RC-5) aumentou de 14 para 22.
O código Manchester também aparece invertido, já que valor lógico alto passa
agora a ser representado pela transição \textit{high-to-low} (1), enquanto o
valor baixo é definido por uma mudança \textit{low-to-high} (0). O primeiro bit
de \textit{start} tem uma duração maior, para garantir o ganho do AGC
(\textit{automatic gain controller}) no circuito receptor; já o segundo, também
de \textit{start}, é sempre mantido em valor alto para sincronização. O bit de 
\textit{toggle}, o qual muda de estado caso uma tecla deixe de ser pressionada,
também possui uma duração mais longa do que os outros bits comuns. O período de
um bit passa de 32 para 16 pulsos, exceto para os casos especiais (AGC e
\textit{toggle}). Por fim, os últimos 16 bits representam o endereço do aparelho
e o referido comando a ser transmitido, respectivamente.

\subsubsection{O Protocolo da Samsung}
Assim como a Philips, a Samsung também utiliza seu próprio padrão para
comunicação entre os controles e os dispositivos eletrônicos, o qual não
possui uma nomenclatura específica. Felizmente, o documento de
\textit{application notes} do microcontrolador S3F80KB~\cite{S3F80KB} presente
em controles da Samsung encontra-se disponível na Internet. O
protocolo define uma sequência de 34 bits, onde ambos os valores 0 e 1 são
representados por uma mudança no estado e diferenciados pela distância entre o
nível baixo dos pulsos.  Antagonicamente ao código Manchester, onde a ordem da
transição define o valor do bit, o protocolo da Samsung sempre define os estados como
uma transição \textit{high-to-low}, na qual é estabelecida uma duração de
560~$\mu$s para o nível alto e duas para o nível baixo: 1690~$\mu$s para o bit
`1' e 560~$\mu$s para o bit `0'.

O nível alto do pulso dos bits normais é caracterizado por um PWM com 
frequência de 37,9~kHz e \textit{duty cycle} que pode variar entre 33\% e 50\% 
do período do pulso.  Aproximadamente 21 pulsos na frequência portadora resultam
na duração de 560~$\mu$s.
O primeiro bit, chamado de \textit{leader}, tem duração mais longa para garantir 
o ganho no circuito receptor: 4,5~ms no nível alto e 4,5~ms no nível baixo; os
16 bits seguintes são divididos em dois blocos exatamente iguais de 8 
\textit{custom} bits cada, provavelmente definindo o endereço do aparelho;
outras duas sessões de 8 bits definem o bloco de dado, onde o segundo bloco é o
complemento dos bits do primeiro, que define os dados propriamente ditos; o
34$\degree$ bit é sempre baixo e encerra o comando.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.75\textwidth]{Figures/samsung_protocol}
	\caption{Esquemático do protocolo da Samsung.}
	\label{fig:samsung}
\end{figure}

\subsection{Produtos Relacionados}
Existem alguns produtos disponíveis no mercado com a finalidade de tornar o
controle de equipamentos eletrônicos mais prático. Um deles é o Harmony Smart 
Control~\cite{harmonysc}, o qual possui em seu ``pacote'' um aplicativo para 
\textit{smartphones} iOS e Android (sem versão para tablets, todavia), um
\textit{hub} e um controle remoto genérico. Segundo a revisão da CNET, vale a
pena pagar US\$ 130 por todas as funcionalidades que o sistema apresenta, como
usar uma conexão de rádio-frequência entre o \textit{smartphone}/controle com o
\textit{hub} (que, infelizmente, ainda não conseguiu se livrar do tão antiquado
infravermelho), o que faz com que o usuário não precise apontar o controle para
o dispositivo que precisa controlar. Todavia, o \textit{hub} precisa estar numa
boa posição para conseguir emitir a informação de forma clara para o aparelho
desejado.

IRdroid é outro aplicativo que permite o controle de aparelhos televisivos com o
celular~\cite{irdroid}. Como o próprio nome sugere, funciona apenas em
dispositivos Android, desde que seu módulo de \textit{hardware} esteja acoplado 
na saída de áudio \textit{jack} do \textit{smartphone}. Versões mais recentes 
já possuem o \textit{hardware} que pode ser acessado via \textit{bluetooth}, 
custando US\$ 60 o mais caro. A grande vantagem é que o IRdroid, além de ser 
baseado na biblioteca LIRC, a qual possui uma vasta quantidade de equipamentos 
em seu banco de dados, possui código livre e disponível.

% Thiago: myuremote

Outras diversas soluções são aplicadas apenas à \textit{smart TVs}, onde a
informação de controle é transmitida por \textit{wifi}. Nenhuma das aplicações
encontradas para TVs convencionais possui suporte à reconhecimento e síntese de
voz \textit{offline} em PT\_BR.
\end{section}
%%% EOF %%%

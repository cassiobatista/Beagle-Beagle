\begin{section}{Revisão Teórica}
% [IEEE'11] Designing Android Applications with both Online and Offline Voice Control of Household Devices
% [IEEE'10] Smart Home Control System for the disabled using the head and the mouth movement
% [IJERA'15] Wi-Fi and Android Based Smart Home Automation for People with Disabilities
 
Como o iOS e o Android foram lançados, respectivamente, em 2007 e 2008, e 
a ascensão dos smartphones é relativamente recente, a ideia de adicionar a eles 
a acessibilidade no controle de equipamentos eletrônicos somente começou a 
revelar resultados concretos a partir de 2010. 
Em~\cite{Barrena11}, o decodificador PocketSphinx foi embarcado em um smartphone
Android para que este pudesse controlar aparelhos domésticos através da
interface de voz. O resultado era enviado para uma SparkFun IOIO Board, a qual,
estando fisicamente conectada ao controle da TV, disparava um determinado 
\textit{trigger}. A justificativa do trabalho era ajudar pessoas afetadas com 
tetraplegia a serem mais independentes; os testes avaliaram o desempenho de
decodificadores embarcados e distribuídos. 

\textcolor{red}{*Cassio: Add another reference here*}

\begin{figure}[!h]
	\centering
	\includegraphics[width=.65\textwidth]{Figures/asr_sch}
	\caption{Esquemático de um sistema ASR}
	\label{fig:asr_sch}
\end{figure}

Os fundamentos do reconhecimento automático de voz, assim como os da síntese de
voz, são descritos com bastante detalhes em~\cite{Huang01}. A arquitetura mais
geral e aceita na literatura é mostrada na Figura~\ref{fig:asr_sch}. Vale
salientar que, ao invés do uso de modelos mais gerais, que descrevem a maior
parte de uma linguagem, serão utilizadas gramáticas livres de contexto, as quais
limitam o vocabulário utilizado a apenas um conjunto de sentenças possíveis,
escolhidas pelo desenvolvedor do sistema. A construção do dicionário fonético
para PT\_BR dar-se-á através do software descrito em~\cite{Siravenha08}; o
tutorial para o treino do modelo acústico encontra-se disponível na página do
projeto Voxforge~\cite{voxforge}, bem como capítulo 3 do livro do
HTK~\cite[p.~22--42]{Young00} (lembrando que o modelo acústico utilizado também
está disponível na página do FalaBrasil); a gramática reconhecida pelo Julius é
criada manualmente de acordo com o descrito na página oficial~\cite{juliussite}.
Instruções de configuração e utilização do Julius encontram-se na documentação
oficial~\cite{julius_book}.

% http://andicelabs.com/2014/03/usb-audio-beaglebone/
Como saída analógica do sistema TTS, a voz sintetizada deve ser reproduzida por
um dispositivo externo à BeagleBone, já que esta não possui auto-falantes
próprios. Como visto em~\cite{andicelabs}, o dispositivo primário de saída de
áudio da BeagleBone é o HDMI, o qual pode ser desabilitado mediante modificações
em parâmetros do kernel. Feito isso, o USB, que é o dispositivo secundário, se
torna o principal, fazendo com que a solução mais simples seja plugar um 
auto-falante (\textit{speaker}) na porta USB.
Na página oficial do eSpeak, um arquivo de cabeçalho (\textit{header}) permite a
utilização de uma API em C/C++, a qual facilita o acesso aos módulos do software
que permitem que a BeagleBone ``fale''~\cite{eSpeak}.

%% http://arduino.cc/en/Tutorial/SimpleAudioPlayer
%% http://www.instructables.com/id/Simple-Wav-Player-Using-Arduino/?lang=pt&ALLSTEPS
%% http://forum.arduino.cc/index.php?topic=49654.0 -- can arduino talk without shield?
%% http://www.instructables.com/id/Twitter-Enabled-Text-to-Speech/
%Links úteis podem ser encontrados em~\cite{arduino_player}
%e~\cite{instructables_player}, os quais ensinam o passo-a-passo para o projeto e
%construção de um circuito amplificador. 

A escolha da plataforma foi fundamental para a esquematização do projeto.
Arduino, Raspberry Pi e BeagleBone Black foram as três principais opções a
serem escolhidas. Diversos tutoriais de comparação entre as plataformas foram
consultados e estão disponíveis na Internet~\cite{mhl,randomnerd,makezine}.
O Arduino, apesar de ser uma ferramenta flexível e com grande capacidade de
interfaceamento com uma vasta quantidade de dispositivos, é uma plataforma
simples, recomendada para projetos de menor porte. O microcontrolador, que pode 
ser programado em C, torna-se muito limitado quando o projeto requer um servidor
estável e relativamente potente;
O Raspberry Pi, por ser bastante completo, já se enquadra no conceito de 
mini computador. Todo o seu armazenamento é fornecido por um cartão SD, além de 
ser possível conectá-lo à Internet através de um conector Ethernet. Sendo
necessário a instalação de um sistema operacional, o Raspberry Pi ainda possui
interface de saída HDMI, tornando-se muito útil para aplicações gráficas.

\begin{table}[!h]
\centering
\caption{Comparação entre as três principais plataformas}
\label{comparison}
\begin{tabular}{c|c c c}
\hline
				& Arduino UNO & BeagleBone Black & Raspberry Pi \\
\hline
Chip			& - & TI AM3359 & BCM2835 SoC full HD \\
CPU				& 20 MHz ATMega328 & 1 GHz ARM Cortex-A8 & 700 MHz ARM1176JZ-F \\
GPU				& - & PowerVR SGX530 & Dual Core VideoCore IV \\
Armazenamento	& 2 kB SRAM & 512 MB DDR3 & 512 MB SDRAM\\
Flash			& 32 kB & 2 GB eMMC, MicroSD & SD, MMC, SDIO card slot\\
GPIO			& 14 & 65 & 8 \\
Video			& - & mini HDMI & HDMI\\
OS				& - & Linux & Linux \\
Amperagem (mA)	& 42 & 210-460 & 150-350 \\
Voltagem (V)	& 7-12 & 5 & 5 \\
USB				& - & 1 Host, 1 Mini Client  & 2 Hosts, 1 Micro Power\\
Ethernet		& - & 1 10/100 Mbps & 1 10/100 Mbps \\
Preço 			& 5 conto & 300 conto & 200 conto \\
%Resolução		& - & 1280x1024 (5:4), 1024x768 (4:3), 1280x720 (16:9), 1440x900 (16:10) all at 16 bit	& 	Extensive from 640x350 up to 1920x1200, this includes 1080p\\
%Camera connector & - & - & Rpi \\
\hline
\end{tabular}
\end{table}

A BeagleBone é comparável ao Raspberry Pi. Entretanto, por ter mais pinos
(GPIO) e um processador mais poderoso, a BeagleBone é uma escolha óbvia para
projetos mais elaborados. Além de possuir diversas opções de conexão, a
BeagleBone une a flexibilidade de interfaceamento do Arduino com a capacidade
de processamento rápido do Raspberry Pi. Apesar da desvantagem no preço, não
restaram muitas dúvidas no momento da escolha dessa plataforma para o projeto.
Uma comparação entre os principais parâmetros dos três equipamentos é dada na
Tabela~\ref{comparison}.

%O cliente Android foi criado também em~\cite{cassio14}. A interface será
%redefinida e métodos serão criados para que haja interação com o banco de dados
%a ser instalado no servidor BeagleBone, o qual ficará encarregado de armazenar
%os dados relacionados à diferentes modelos ou fabricantes de televisores.

\noindent
\textcolor{red}{$\downarrow$ Thiago: LIRC $\downarrow$} 

O funcionamento de controles remotos, com ênfase nos baseados em luz
infravermelha para televisores, é explicado de de forma clara e detalhada em
diversos tutoriais para ``curiosos'' disponíveis na Internet, como os da revista
Mundo Estranho~\cite{mundoestranho} e do blog \textit{How Stuff Works?} da
UOL~\cite{uol_hsw}. A maioria dos aparelhos eletrônicos atualmente recebe
informação através de sensores infravermelhos localizados em painéis frontais.
Um grande problema é a inteferência que surge com a vasta transferência de
informação via IR. Devido à isso, a comunicação entre o controle remoto e a
televisão ocorre geralmente em 4 passos: um comando \textit{start} inicia a
transferência, seguido dos bits do comando específico (como aumentar o volume,
por exemplo) e do endereço do aparelho. Por fim, um comando de \textit{stop}
encerra o envio de bits. Dessa forma, a chance de a informação ser reconhecida
por mais de um aparelho é baixa (salvo o caso de serem dois equipamentos do
mesmo tipo e da mesma empresa).

Uma das grandes dificuldades relacionadas à comunicação IR para controle de
equipamentos é que cada empresa praticamente segue o seu próprio padrão de
transmissão de informação: o número, a ordem e o significado dos bits é variado, 
a modulação e codificação usada são diferentes e a frequência dos pulsos pode
oscilar entre 32~kHz e 40~kHz, chegando a 50~kHz em determinados aparelhos mais
modernos. Além disso, tão raro quanto o seguimento de uma comunicação IR
padronizada, a disponibilização de documentação pelos fabricantes também é
bastante escassa. A Philips, por exemplo, utiliza seu próprio protocolo de
comunicação chamado RC-5. A última documentação foi liberada em 1992, quando
ainda não existiam muitos dos equipamentos eletrônicos atuais, como \textit{home
theaters} ou DVDs. Nesse padrão, os bits são codificados de acordo com o código
de Manchester, onde cada bit, transmitido dentro de um período fixo, é
representado por uma transição \textit{high-to-low} (0) ou \textit{low-to-high}
(1).  Esses padrões de dados são obtidos através de uma operação do tipo XOR
(OU-Exclusivo) realizada entre o clock do dispositivo e o dado propriamente
dito~\cite{rc5_wiki}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.88\textwidth]{Figures/sch_rc5}
	\caption{Esquemático do protocolo RC-5 da Philips.}
	\label{fig:rc5}
\end{figure}

A Figura~\ref{fig:rc5} mostra a informação referente ao comando ``diminuir
volume'' contida num vetor de 14 bits. Os 11 últimos bits definem o endereço do
aparelho de destino e o comando em si. Pode-se observar que qualquer bit é
representado por duas partes, sendo uma metade em nível baixo e a outra, em
nível alto. Cada nível ocorre num intervalo de 32 perídos. O nível alto é gerado
por um PWM de \textit{duty cycle} igual a 25\% do período do pulso. Essa
percentagem define o tempo em que o IR Led permance aceso, ou seja, no nível
alto, o IR Led permanece ligado por período de $0,25\times1/36~kHz$ e desligado
por $0,75\times1/36~kHz$, sendo o processo repetido 32 vezes.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.65\textwidth]{Figures/rc6}
	\caption{Esquemático do protocolo RC-6 da Philips.}
	\label{fig:rc6}
\end{figure}

Os aparelhos mais novos já implementam a versão atualizada desse protocolo,
chamado de RC-6. Embora a Philips não tenha disponibilizado qualquer
documentação sobre este protocolo, há fóruns na Internet que, através da
aplicação de engenharia reversa, conseguem descrever o padrão utilizado na
construção do sinal. Pela Figura~\ref{fig:rc6}, é fácil notar que a quantidade
de bits carregada pelo sinal (em comparação com o RC-5) aumentou de 14 para 22.
O código Manchester também aparece invertido, já que valor lógico alto passa
agora a ser representado pela transição \textit{high-to-low} (1), enquanto o
valor baixo (0) é definido por uma mudança \textit{low-to-high}. O primeiro bit
de \textit{start} tem uma duração maior, para garantir o ganho do AGC no
circuito receptor; já o segundo, também de \textit{start}, é sempre mantido em
valor alto. O bit de \textit{toggle}, o qual muda de estado caso uma tecla deixe
de ser pressionada, também possui uma duração mais longa do que os outros bits
comuns.  Por fim, os últimos 14 bits representam o endereço do aparelho e o
referido comando a ser transmitido, respectivamente.

\subsection{Produtos Relacionados}
Existem alguns produtos disponíveis no mercado com a finalidade de tornar o
controle de equipamentos eletrônicos mais prático. Um deles é o \textit{Harmony
Smart Control}~\cite{harmonysc}, o qual possui em seu ``pacote'' um aplicativo
para iOS e Android (porém sem versão para tablets; somente smartphones), um hub
e um controle remoto genérico. Segundo a revisão da CNET, vale a pena pagar US\$
130 por todas as funcionalidades que o sistema apresenta, como usar uma conexão
RF entre o smartphone/controle com o hub (que, infelizmente, ainda não conseguiu
se livrar do tão antiquado IR), o que faz com que o usuário não precise apontar
o controle para o dispositivo que precisa controlar. Todavia, o hub precisa
estar numa boa posição para conseguir emitir a informação de forma clara para o
aparelho desejado.

IRdroid é outro aplicativo que permite o controle de aparelhos televisivos com o
celular~\cite{irdroid}. Como o próprio nome sugere, funciona apenas em
dispositivos Android, desde que seu módulo de hardware esteja acoplado na saída
de audio jack do smartphone. Versões mais recentes já possuem o hardware que
pode ser acessado via bluetooth, custando US\$ 60 o mais caro. A grande vantagem
é que o IRdroid, além de ser baseado na biblioteca LIRC, a qual possui uma vasta
quantidade de equipamentos em seu banco de dados, possui código livre e
disponível.

Outras diversas soluções são aplicadas apenas à \textit{smart TVs}, onde a
informação de controle é transmitida por wifi. Nenhuma das aplicações
encontradas para TVs convencionais possui suporte à reconhecimento e síntese de
voz offline em PT\_BR.
\end{section}
%%% EOF %%%

\begin{section}{Metodologia}
O servidor, por ser o elemento chave na consolidação do projeto, deve ser o 
módulo a ser prioritariamente configurado, a fim de ser preparado para atender
às devidas requisições, bem como executar qualquer tipo de aplicação solicitada.
Sendo assim, a instalação do sistema operacional Ubuntu foi tomada como primeiro
passo.  As dependências a serem instaladas são mostradas na
Lista~\ref{lst:dependences}.

É importante ressaltar que os sistemas operacionais embarcados são
simplificações de sistemas operacionais mais robustos, tendo a maior parte das
suas funcionalidades reduzidas ou simplificadas para se adequar à uma plataforma
de menor porte. Por isso, a preparação deve ocorrer a partir dos pacotes mais
básicos, como o GCC, por exemplo. Outros pacotes devem ser instalados de forma
gradual, tais quais os requeridos pelo Julius, eSpeak e os necessários para a
implementação do servidor LAMP em C.

\begin{lstlisting}[language=bash, caption={Pre-instalação de dependências no
servidor}, label={lst:dependences}]
# general dependences
build-essential alsa-tools alsa-base alsa-utils sox

# eSpeak dependences
libespeak-dev libportaudio2 libportaudio-dev

# Julius dependences
libasound2 libasound2-dev 

# LAMP dependences
apache2 libapache2-mod-fastcgi # apache server
mysql-server libapache2-mod-auth-mysql php5-mysql # MySQL
libmysqlclient-dev # C
phpmyadmin # (opcional?)
\end{lstlisting}

%\begin{figure}[!h]
%	\centering
%	\includegraphics[width=.80\textwidth]{Figures/csr}
%	\caption{Esquemático do cliente Android.}
%	\label{fig:lapscsr_sch}
%\end{figure}

% http://eda.eme.ro/handle/10598/28187
Em~\cite{cassio14}, o Julius foi configurado para funcionar em modo servidor
através da opção nativa ``-adinnet'' (A/D \textit{Input from Network}, conversão 
A/D com entrada pela rede). Isso permite que o Julius receba amostras de áudio
via \textit{streaming} através de uma comunicação com um cliente genérico via
\textit{socket}. O código foi alterado para que o resultado gerado pelo Julius,
também conhecido como sentença, seja retornado ao cliente através desse mesmo
\textit{socket}. Além disso, uma aplicação foi construída sobre a plataforma
Android 2.3 exclusivamente para se comunicar com o servidor. Basicamente, as 
amostras de áudio obtidas pelo microfone do aparelho são enviadas, enquanto são
paralelamente analisadas a fim de se detectar o silêncio do fim da fala do
usuário. Feito isso, o aplicativo apenas aguarda a sentença a ser enviada pelo
servidor.

A construção do dicionário fonético para o PT\_BR se dá por meio do
\textit{software} \texttt{lapsg2p}, o qual recebe uma lista de palavras como
entrada e gera suas transcrições fonéticas, conforme visto na lista abaixo, à
direita. Já a gramática é utilizada para restringir o vocabulário, de modo a
gerar somente uma das senteças listadas, como mostrado na lista abaixo, à
esquerda. A construção da gramática no formato do Julius utiliza diretamente o
dicionário fonético em seu escopo.

\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[label={lst:gram}]
<s> aumentar volume </s>
<s> diminuir volume </s>
<s> canal mais </s>
<s> canal menos </s>
<s> ligar televisão </s>
<s> desligar televisão </s>
<s> cadastrar controle </s>
<s> selecionar controle </s>
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[label={lst:dict}]
aumentar	a u~ m e~  t a X  
diminuir	dZ i~ m i~ n u j X  
volume		v o l u~ m i  
canal		k a n a w  
mais		m a j s
menos		m e~ n u s
televisão	t e l e v i z a~ w~   
...
\end{lstlisting}
\end{minipage}

% http://stackoverflow.com/questions/2661129/espeak-sapi-dll-usage-on-windows
A proposta do trabalho é adicionar funcionalidades ao código do Julius,
permitindo a produção de voz sintetizada através da incorporação da API do 
eSpeak e a transmissão de informação para a TV através de um led IR conectado
a um GPIO. Um sensor IR ficará encarregado de receber informações de diferentes
controles remotos para que sejam guardadas como registros no banco de dados.

Toda a organização do trabalho, bem como a comunicação entre os membros sobre os
passos tomados no decorrer do trabalho será feita através da plataforma
Trello~\cite{trello}.\\

Um controle para a TV Philips 39PFL3008D/78 foi usado como base para a análise
do sinal emitido. Inicialmente, um arduino UNO fui utilizado para verificar
o tempo em que o IR led permanecia ativo e inativo, armazenando-o
em uma matriz de duas colunas. O Matlab foi utilizado para converter a matriz em
um vetor único, no qual os índices ímpares representavam o tempo de duração do
modo \textit{burst} do IR led e as posições pares, o tempo em que o IR led
permanecia \textit{idle}. Sendo assim, o vetor no qual as durações dos nívels
altos e baixos alternavam-se entre si foi convertido para uma forma de onda
quadrada, semelhante à mostrada na Figura~\ref{fig:rc6}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{Figures/cmds}
	\caption{Mudança nos bits de comando após pressionar NÃO consecutivamente 
			4 botões diferentes.}
	\label{fig:cmds_sch}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{Figures/volume+}
	\caption{Mudança no bit de Toggle após pressionar o botão ``Volume Mais'' por
			4 vezes consecutivas.}
	\label{fig:vol+}
\end{figure}


Como o sistema foi projetado visando o controle de diversos aparelhos eletrônicos, em que cada aparelho eletrônico 
detém um conjunto de comandos, sendo cada comando composto de vários campos (bitstreams), a adoção de um banco de 
dados vem como solução para facilitar o acesso à todos esses comandos, bem como manter com segurança uma série de 
dados que serão constantemente manipulados e podem sempre ser recuperados apenas olhando para o banco.

Inicialmente, usamos no banco apenas uma tabela que é para a televisão, esta tabela entitulada "TV" têm como 
atributos a sua marca e os campos dos comandos que usaremos para reenviar à tv, sendo eles "volume+", 
"volume-","canal+", "canal-","ligar","desligar", "endereço", "start", "stop". Com isso, podemos satisfatoriamente 
acessar quaisquer campos para montar um determinado comando, apenas com um simples SELECT campo FROM TV WHERE 
$marca='marca\_da\_tv'$, com isso podemos concatenar estas bitstreams e mandar posteriormente para o led IR.

O acesso ao banco de dados é todo feito por meio da linguagem C, para tal foi usado uma biblioteca especial chamada 
$my\_sql.h$, em que conseguimos fazer queries passando o comando em mysql como uma string.

\begin{table}[h]
\centering
\caption{Tabela TV do nosso BD}
\begin{tabular}{cccccccccc}
%\hline
%Tabela TV
\hline
marca & volume+ & volume- & canal+ & canal- & ligar & desligar & endereço & start & stop \\
\hline
lg & 10111011 & 11110110 & 11000010 & 00010111 & 01011111 & 11000000 & 11011010 & 11010111 & 00011111 \\
sony & 11110110 & 01011111 & 00011111 & 10111011 & 11000000 & 11011010 & 11010111 & 00010111 & 11010111 \\
samsung & 00110111 & 11000010 & 11010000 & 11011110 & 11011100 & 01010111 & 11011010 & 11010111 & 01011111 \\
phillips & 00011111 & 10111011 & 11000000 & 11011010 & 11010111 & 00010111 & 11000010 & 00010111 & 10101010 \\
\hline
\end{tabular}
\end{table}


\noindent
\textcolor{red}{*Thiago: Detalhes sobre o que foi feito com o Arduino*}\\
\textcolor{red}{*Gabriel: Detalhes sobre o que foi convertido do Arduino para a BBB*}
\end{section}
%%% EOF %%%

\begin{section}{Metodologia}
O servidor, por ser o elemento chave na consolidação do projeto, deve ser o 
módulo a ser prioritariamente configurado, a fim de ser preparado para atender
às devidas requisições, bem como executar qualquer tipo de aplicação solicitada.
Sendo assim, a instalação do sistema operacional Debian foi tomada como primeiro
passo, visto que houveram muitos problemas na instalação do Ubuntu e do 
Ångström. As dependências a serem instaladas são mostradas na 
Lista~\ref{lst:dependences}.

É importante ressaltar que os sistemas operacionais embarcados são
simplificações de sistemas operacionais mais robustos, tendo a maior parte das
suas funcionalidades reduzidas para se adequar a uma plataforma
de menor porte. Por isso, a preparação deve ocorrer a partir dos pacotes mais
básicos, como o GCC, por exemplo. Outros pacotes devem ser instalados de forma
gradual, tais quais os requeridos pelo Julius, eSpeak e os necessários para a
implementação do servidor LAMP em C.

\begin{lstlisting}[language=bash, caption={Pre-instalação de dependências no
servidor}, label={lst:dependences}]
# general dependences
build-essential alsa-tools alsa-base alsa-utils sox

# eSpeak dependences
libespeak-dev libportaudio2 libportaudio-dev

# Julius dependences
libasound2 libasound2-dev 

# LAMP dependences
apache2 libapache2-mod-fastcgi # apache server
mysql-server libapache2-mod-auth-mysql php5-mysql # MySQL
libmysqlclient-dev # C
\end{lstlisting}

\subsection{Entrada de Áudio e Reconhecimento de Voz}
Em~\cite{Cassio14}, o Julius foi configurado para funcionar em modo servidor
através da opção nativa ``-adinnet'' (A/D \textit{Input from Network}, conversão 
A/D com entrada pela rede). Isso permite que o Julius receba amostras de áudio
via \textit{streaming} através de uma comunicação com um cliente genérico via
\textit{socket}. O código foi alterado para que o resultado gerado pelo Julius,
também conhecido como sentença, seja retornado ao cliente através desse mesmo
\textit{socket}. Além disso, uma aplicação foi construída sobre a plataforma
Android exclusivamente para se comunicar com o servidor. Basicamente, as 
amostras de áudio obtidas pelo microfone do aparelho são enviadas, enquanto são
paralelamente analisadas a fim de se detectar o silêncio do fim da fala do
usuário. Feito isso, o aplicativo apenas aguarda a sentença a ser enviada pelo
servidor.

A construção do dicionário fonético para o PT\_BR se dá por meio do
\textit{software} \texttt{lapsg2p}, o qual recebe uma lista de palavras como
entrada e gera suas transcrições fonéticas, conforme visto na lista abaixo, à
direita. Já a gramática é utilizada para restringir o vocabulário, de modo a
gerar somente uma das senteças listadas, como mostrado na lista abaixo, à
esquerda. A construção da gramática no formato do Julius utiliza diretamente o
dicionário fonético em seu escopo.

\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[label={lst:gram}]
<s> aumentar volume </s>
<s> diminuir volume </s>
<s> canal mais </s>
<s> canal menos </s>
<s> ligar televisão </s>
<s> desligar televisão </s>
<s> cadastrar controle </s>
<s> selecionar controle </s>
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[label={lst:dict}]
aumentar	a u~ m e~  t a X  
diminuir	dZ i~ m i~ n u j X  
volume		v o l u~ m i  
canal		k a n a w  
mais		m a j s
menos		m e~ n u s
televisão	t e l e v i z a~ w~   
...
\end{lstlisting}
\end{minipage}

% http://stackoverflow.com/questions/2661129/espeak-sapi-dll-usage-on-windows
\subsection{Análise do Sinal Infravermelho}
Inicialmente, um Arduino UNO fui utilizado para verificar o tempo em que o IR
LED permanecia ativo e inativo, armazenando-o em uma matriz de duas colunas,
como visto no Apêndice~\ref{app:arduino}. O Octave foi utilizado para converter
a matriz em um vetor único, no qual os índices ímpares representavam o tempo de
duração do modo \textit{burst} do IR LED e as posições pares, o tempo em que o
IR LED permanecia \textit{idle}. Sendo assim, o vetor no qual as durações dos
níveis altos e baixos alternam-se entre si foi convertido para uma forma de onda
quadrada, a qual mostra claramente as características dos protocolos descritas
na seção anterior.

\subsubsection{Philips}
O controle RC2954201/01 da TV Philips 39PFL3008D/78 foi usado como base para a 
análise do sinal emitido. A Figura~\ref{fig:cmds} mostra a forma de onda
quadrada para 4 botões diferentes pressionados de forma não consecutiva. Pode-se
notar que os sinais são exatamente iguais até aproximadamente $t=15ms$, onde
começam a ser exibidos os bits referentes ao comando específico. Já na
Figura~\ref{fig:vol+}, o botão ``volume mais'' foi pressionado por quatro vezes
consecutivas. Percebe-se que os sinais são completamente idênticos, exceto o bit
de \textit{toggle}, o qual muda sempre que um botão é solto.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.9\textwidth]{Figures/cmds}
	\caption{Mudança nos bits de comando após pressionar NÃO consecutivamente 
			4 botões diferentes.}
	\label{fig:cmds}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=.9\textwidth]{Figures/volume+}
	\caption{Mudança no bit de \textit{toggle}(T) após pressionar o botão 
			``volume+'' por 4 vezes consecutivas.}
	\label{fig:vol+}
\end{figure}

\subsubsection{Samsung}
O controle da TV Samsung LT22B300LBMZD também foi usado para análise do sinal
emitido à TV. A Figura~\ref{fig:cmds_samsung} mostra a forma de onda quadrada
obtida após o pressionamento consecutivo de 4 botões diferentes. Nota-se que os
sinais são idênticos até o final do segundo bloco \textit{custom}, o qual é
imediatamente seguido pelos blocos de dados.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.9\textwidth]{Figures/cmds_samsung}
	\caption{Mudança nos bits de comando após pressionar consecutivamente 4 
			botões diferentes.}
	\label{fig:cmds_samsung}
\end{figure}

\subsection{Envio do Sinal Infravermelho}
Nas seções seguintes, será mostrado que a atribuição de valores aos pinos da
BeagleBone é feita através da escrita em arquivos por quaisquer linguagens de
programação e que, apesar de prática e funcional, o tempo demandado para a
execução desta tarefa não atende às exigências dos protocolos, os quais
requerem faixas na ordem de microssegundos para modular os bits transmitidos. 
Em outras palavras, a BBB acabou sendo mais lenta do que o Arduino para emitir 
sinais à TV. 

\begin{figure}[!h]
	\centering
	\includegraphics[width=.55\textwidth]{Figures/duplex_tx}
	\caption{Protocolo de envio do \textit{bitstream} da BeagleBone para o Arduino.}
	\label{fig:send2uno}
\end{figure}

A BeagleBone continua sendo o servidor de voz e, de acordo com o resultado
retornado pelo sistema de reconhecimento, é realizada a busca por um vetor de
bits no banco de dados. Essa \textit{bitstream} é transmitida bit a bit para o
Arduino através de pinos, seguindo um protocolo tal qual o ilustrado na
Figura~\ref{fig:send2uno}. Há dois pinos de controle e um de dados em cada
plataforma. Quando a BBB quer transmitir, um sinal alto é colocado no pino de
controle. Imediatamente após o Arduino perceber esse sinal, o caminho para o bit
de dados é aberto e uma resposta é dada à BBB também na forma de um sinal alto; 
caso o Arduino ainda esteja processando o bit de dados anterior, a 
\textit{stream} de dados permanece fechada e um sinal baixo é enviado à BBB pelo
canal de controle. Após finalizar o envio do bit, a BeagleBone coloca um sinal
baixo no pino de controle. O processo é repetido para todos os bits do vetor.

Em posse do vetor, o Arduino passa cada bit a função que o modula e envia de 
acordo com o protocolo da TV em questão.

\subsection{Banco de Dados MySQL}
Como o sistema foi projetado para, futuramente, dar suporte ao controle de 
diversos aparelhos eletrônicos, a adoção de um banco de dados foi vista como 
solução para facilitar o acesso a uma maior variedade de dispositivos e, assim,
tornar o projeto um sistema de propósito mais geral. Além disso, a segurança
dos dados, que serão constantemente manipulados, será mantida, podendo estes ser
recuperados apenas olhando para o banco. 

Inicialmente, apenas a entidade TELEVISÃO foi criada, onde uma tabela intitulada
``TV'' contém atributos como a marca do aparelho e os comandos a serem
transmitidos, como visto na Tabela~\ref{tab:tv}. Com isso, quaisquer campos
podem ser satisfatoriamente acessados através de um simples código SQL (como o
mostrado abaixo). Assim, pode-se recuperar os bits de referência para,
posteriormente, decodificá-los de acordo com o protocolo do aparelho e,
finalmente, construir a informação exata a ser passada para o IR LED.

\begin{lstlisting}[style=code, language=sql]
SELECT campo FROM TV WHERE marca='marca_da_tv' 
\end{lstlisting}

O acesso ao banco de dados é inteiramente intermediado pela linguagem C. Para 
tal, uma biblioteca especial chamada \texttt{mysql.h} foi utilizada, na qual as
\textit{queries} são realizadas pela passagem de um comando SQL como uma
\textit{string} (Vide Apêndice~\ref{app:lamp}).

\begin{table}[h]
\centering
\caption{Exemplo hipotético de uma tabela entitulada `TV' no banco de dados.}
\label{tab:tv}
\begin{tabular}{c|ccccc}
\hline
Marca   & volume+  & volume-  & canal+   & canal-   & ligar    \\ 
\hline
Lg      & 10111011 & 11110110 & 11000010 & 00010111 & 01011111 \\
Sony    & 11110110 & 01011111 & 00011111 & 10111011 & 11000000 \\
Samsung & 00110111 & 11000010 & 11010000 & 11011110 & 11011100 \\
Philips & 00011111 & 10111011 & 11000000 & 11011010 & 11010111 \\ 
\hline
\end{tabular}
\end{table}

% Thiago: Detalhes sobre o que foi feito com o Arduino

\begin{subsection}{GPIO}
Como no Arduino, a BBB possui muitos pinos de entrada e saída para 
diversas funções, algo que o Raspberry Pi carece. Os GPIOs (\textit{general
purpose input/output}, ou pinos de entrada e saída de propósito geral) podem ser
usados da forma mais conveniente ao desenvolvedor, sendo possível controlar a
tensão de saída, receber \textit{feedback} de sensores digitais e analógicos,
etc. O processador possui 128
pinos de GPIO divididos em 4 módulos de 32 pinos cada. Porém, o mapeamento
entre os pinos da BeagleBone Black e os do processador não é exatamente igual 
(da mesma forma que o número dos pinos do Arduino UNO não equivale aos do
ATmega328, por exemplo). Portanto, é necessário saber como os pinos estão
dispostos na placa.

%\begin{figure}[!h]
%	\centering
%	\includegraphics[width=\textwidth]{Figures/BBBp8}
%	\caption{Mapeamento de Pinos do Header P8 da BeagleBone}
%	\label{fig:BBBp8}
%\end{figure}

\begin{table}[h]
\centering
\caption{Mapeamento de Pinos do \textit{Header} P8 da BeagleBone}
\label{tab:BBBp8}
\begin{tabular}{cccccclc}
\hline
\textit{Head pin} & \$Pins & Endereço & \textit{offset} & N$\degree$ GPIO & Nome & Modo7 & Pino \\ 
\hline \hline
 1,2 &   &       &     &    & DGND     &           &     \\
 3   & 6 & 0x818 & 018 & 38 & GPIO\_6  & gpio1[6]  & R9  \\
 4   & 7 & 0x81c & 01c & 39 & GPIO\_7  & gpio1[7]  & T9  \\ 
 5   & 2 & 0x808 & 008 & 34 & GPIO\_2  & gpio1[2]  & R8  \\ 
 6   & 3 & 0x80c & 00c & 35 & GPIO\_3  & gpio1[3]  & T8  \\ 
13   & 9 & 0x824 & 024 & 23 & EHRPWM2B & gpio0[23] & T10 \\
19   & 8 & 0x820 & 020 & 22 & EHRPWM2A & gpio0[22] & U10 \\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Mapeamento de Pinos do \textit{Header} P9 da BeagleBone}
\label{tab:BBBp9}
\begin{tabular}{cccccclc}
\hline
\textit{Head pin} & \$Pins & Endereço & \textit{offset} & N$\degree$ GPIO & Nome & Modo7 & Pino \\ 
\hline \hline
 1,2 & 	  &		  & 	& 	 & DGND        & 		   &	 \\
 3,4 & 	  & 	  & 	& 	 & DC\_3.3V    & 		   &	 \\
 5,6 & 	  & 	  & 	& 	 & VDD\_5V     & 		   &	 \\ 
 7,8 & 	  & 	  & 	& 	 & SYS\_5V 	   & 		   &	 \\ 
 9   & 	  & 	  & 	& 	 & PWR\_BUT    & 		   &	 \\ 
10   & 	  & 	  & 	& 	 & SYS\_RESETn & 		   & A10 \\
11   & 28 & 0x870 & 070 & 30 & UART4\_RXD  & gpio0[30] & T17 \\
12   & 30 & 0x878 & 078 & 60 & GPIO1\_28   & gpio0[28] & U18 \\
\hline
\end{tabular}
\end{table}

Como o objetivo não é prototipar a partir do processador, o mapeamento correto 
dos pinos é crucial para conseguir alguma saída válida dos pinos da placa. 
% e sim usar a placa
%de desenvolvimento a qual possui pinos mais acessíveis. 
As Tabelas~\ref{tab:BBBp8} e~\ref{tab:BBBp9} mostram parte desse mapeamento.

Existem 3 formas de se acessar e controlar os pinos de GPIO. A primeira, 
através da IDE web que vem instalada no Ångström de fábrica, não é viável, visto
que o sistema operacional foi trocado pelo Debian. A segunda consiste em iniciar
o módulo e atribuir valores através de registradores, tal como explicado no
\textit{datasheet}~\cite{am335x}, mas, por ser mais complexa, despenderia muito
tempo e seria pouco portável. A última solução foi introduzida com o 
\textit{kernel} 3.8.x do Linux embarcado, acessando as interfaces de GPIO
através da simples atribuição de valores a arquivos. Tal processo só pode ser
executado como \emph{root}, então deve-se entender bem o que está fazendo antes
de executar tais comandos.

Os arquivos de configuração do GPIO estão localizados no caminho
\texttt{/sys/class/gpio}. Ao se modificar o arquivo \texttt{export}, o qual 
inicializa o pino, o diretório \texttt{gpiochipXX}, que contém os arquivos
necessários para a configuração do pino, é criado. Apenas os arquivos
\texttt{direction} e \texttt{value} são necessários para a tarefa de piscar um
LED, os quais indicam se o pino será de entrada ou saída e o valor que será
atribuído ao pino, respectivamente.

\begin{lstlisting}[language=bash]
echo 51  > /sys/class/gpio/export # exporta o pino 51 / GPIO_19 / pino 16
echo out > /sys/class/gpio/gpiochip51/direction # define o pino como saída
for i in `seq 10`; do
	echo 1 > /sys/class/gpio/gpiochip51/value # seta o valor alto no pino
	sleep 1
	echo 0 > /sys/class/gpio/gpiochip51/value # seta o valor baixo no pino
	sleep 1
done 
echo 51 > /sys/class/gpio/unexport # libera o pino 51 / GPIO_19 / pino 16
\end{lstlisting}

%\begin{equation}
%	\text{GPIO Number on BBB} =  1 \times 32 + \text{GPIO Number on Mode7} \notag
%\end{equation}

Os comandos listados acima são o suficiente para piscar um LED conectado ao
pino 51, ou pino 16 do \textit{header} P9.
\end{subsection}
\end{section}
%%% EOF %%%

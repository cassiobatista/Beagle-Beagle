\begin{section}{Metodologia}
O servidor, por ser o elemento chave na consolidação do projeto, deve ser o 
módulo a ser prioritariamente configurado, a fim de ser preparado para atender
às devidas requisições, bem como executar qualquer tipo de aplicação solicitada.
Sendo assim, a instalação do sistema operacional Debian foi tomada como primeiro
passo, visto que houveram muitos problemas na instalação do Ubuntu e do 
Angstrom. As dependências a serem instaladas são mostradas na 
Lista~\ref{lst:dependences}.

É importante ressaltar que os sistemas operacionais embarcados são
simplificações de sistemas operacionais mais robustos, tendo a maior parte das
suas funcionalidades reduzidas ou simplificadas para se adequar à uma plataforma
de menor porte. Por isso, a preparação deve ocorrer a partir dos pacotes mais
básicos, como o GCC, por exemplo. Outros pacotes devem ser instalados de forma
gradual, tais quais os requeridos pelo Julius, eSpeak e os necessários para a
implementação do servidor LAMP em C.

\begin{lstlisting}[language=bash, caption={Pre-instalação de dependências no
servidor}, label={lst:dependences}]
# general dependences
build-essential alsa-tools alsa-base alsa-utils sox

# eSpeak dependences
libespeak-dev libportaudio2 libportaudio-dev

# Julius dependences
libasound2 libasound2-dev 

# LAMP dependences
apache2 libapache2-mod-fastcgi # apache server
mysql-server libapache2-mod-auth-mysql php5-mysql # MySQL
libmysqlclient-dev # C
phpmyadmin # (opcional?)
\end{lstlisting}

\subsection{Entrada de Áudio e Reconhecimento de Voz}
Em~\cite{Cassio14}, o Julius foi configurado para funcionar em modo servidor
através da opção nativa ``-adinnet'' (A/D \textit{Input from Network}, conversão 
A/D com entrada pela rede). Isso permite que o Julius receba amostras de áudio
via \textit{streaming} através de uma comunicação com um cliente genérico via
\textit{socket}. O código foi alterado para que o resultado gerado pelo Julius,
também conhecido como sentença, seja retornado ao cliente através desse mesmo
\textit{socket}. Além disso, uma aplicação foi construída sobre a plataforma
Android exclusivamente para se comunicar com o servidor. Basicamente, as 
amostras de áudio obtidas pelo microfone do aparelho são enviadas, enquanto são
paralelamente analisadas a fim de se detectar o silêncio do fim da fala do
usuário. Feito isso, o aplicativo apenas aguarda a sentença a ser enviada pelo
servidor.

A construção do dicionário fonético para o PT\_BR se dá por meio do
\textit{software} \texttt{lapsg2p}, o qual recebe uma lista de palavras como
entrada e gera suas transcrições fonéticas, conforme visto na lista abaixo, à
direita. Já a gramática é utilizada para restringir o vocabulário, de modo a
gerar somente uma das senteças listadas, como mostrado na lista abaixo, à
esquerda. A construção da gramática no formato do Julius utiliza diretamente o
dicionário fonético em seu escopo.

\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[label={lst:gram}]
<s> aumentar volume </s>
<s> diminuir volume </s>
<s> canal mais </s>
<s> canal menos </s>
<s> ligar televisão </s>
<s> desligar televisão </s>
<s> cadastrar controle </s>
<s> selecionar controle </s>
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[label={lst:dict}]
aumentar	a u~ m e~  t a X  
diminuir	dZ i~ m i~ n u j X  
volume		v o l u~ m i  
canal		k a n a w  
mais		m a j s
menos		m e~ n u s
televisão	t e l e v i z a~ w~   
...
\end{lstlisting}
\end{minipage}

% http://stackoverflow.com/questions/2661129/espeak-sapi-dll-usage-on-windows
%A proposta do trabalho é adicionar funcionalidades ao código do Julius,
%permitindo a produção de voz sintetizada através da incorporação da API do 
%eSpeak e a transmissão de informação para a TV através de um led IR conectado
%a um GPIO. Um sensor IR ficará encarregado de receber informações de diferentes
%controles remotos para que sejam guardadas como registros no banco de dados.

%Toda a organização do trabalho, bem como a comunicação entre os membros sobre os
%passos tomados no decorrer do trabalho será feita através da plataforma
%Trello~\cite{trello}.\\

\subsection{Análise do Sinal IR}
O controle RC2954201/01 da TV Philips 39PFL3008D/78 foi usado como base para a 
análise do sinal emitido. Inicialmente, um arduino UNO fui utilizado para
verificar o tempo em que o IR led permanecia ativo e inativo, armazenando-o em
uma matriz de duas colunas, como visto no Apêndice~\ref{app:arduino}. O Octave
foi utilizado para converter a matriz em um vetor único, no qual os índices
ímpares representavam o tempo de duração do modo \textit{burst} do IR led e as
posições pares, o tempo em que o IR led permanecia \textit{idle} (Vide
Apêndice~\ref{app:matlab}). Sendo assim, o vetor no qual as durações dos níveis
altos e baixos alternam-se entre si foi convertido para uma forma de onda
quadrada, semelhante à mostrada na Figura~\ref{fig:rc6}.  A
Figura~\ref{fig:cmds} mostra a forma de onda quadrada para 4 botões diferentes
pressionados de forma não consecutiva. Pode-se notar que os sinais são
exatamente iguais até aproximadamente $t=15ms$, onde começam a ser exibidos os
bits referentes ao comando específico. Já na Figura~\ref{fig:vol+}, o botão
``volume mais'' foi pressionado por quatro vezes consecutivas. Percebe-se que os
sinais são completamente idênticos, exceto o bit de \textit{toggle}, o qual muda
sempre que um botão é solto.

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{Figures/cmds}
	\caption{Mudança nos bits de comando após pressionar NÃO consecutivamente 
			4 botões diferentes.}
	\label{fig:cmds}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{Figures/volume+}
	\caption{Mudança no bit de \textit{toggle}(T) após pressionar o botão 
			``volume+'' por 4 vezes consecutivas.}
	\label{fig:vol+}
\end{figure}

\subsection{Banco de Dados MySQL}
Como o sistema foi projetado para, futuramente, dar suporte ao controle de 
diversos aparelhos eletrônicos, a adoção de um banco de dados foi vista como 
solução para facilitar o acesso à uma maior variedade de dispositivos e, assim,
tornar o projeto em um sistema de propósito mais geral. Além disso, a segurança
dos dados, que serão constantemente manipulados, será mantida, podendo estes ser
recuperados apenas olhando para o banco. (????)

Inicialmente, apenas a entidade TELEVISÃO foi criada, onde uma
tabela entitulada ``TV'' contém atributos como a marca do aparelho e os comandos
a serem transmitidos, como visto na Tabela~\ref{tab:tv}. Com isso,
quaisquer campos podem ser satisfatoriamente acessados através de um simples
código SQL (como o mostrado abaixo), a fim de se montar um determinado comando.
Assim, podemos concatenar os bits e, posteriormente, enviar para o led IR.

\begin{lstlisting}[language=sql]
SELECT campo FROM TV WHERE marca='marca_da_tv' 
\end{lstlisting}

O acesso ao banco de dados é todo feito por meio da linguagem C. Para tal, foi-se
utilizada uma biblioteca especial chamada \texttt{mysql.h}, na qual as
\textit{queries} são feitas pela passagem de um comando SQL como uma
\textit{string} (Vide Apêndice~\ref{app:lamp}).

\begin{table}[h]
\centering
\caption{Tabela TV}
\label{tab:tv}
\begin{tabular}{c|ccccc}
\hline
Marca   & volume+  & volume-  & canal+   & canal-   & ligar    \\ 
\hline
Lg      & 10111011 & 11110110 & 11000010 & 00010111 & 01011111 \\
Sony    & 11110110 & 01011111 & 00011111 & 10111011 & 11000000 \\
Samsung & 00110111 & 11000010 & 11010000 & 11011110 & 11011100 \\
Philips & 00011111 & 10111011 & 11000000 & 11011010 & 11010111 \\ 
\hline
\end{tabular}
\end{table}

% Thiago: Detalhes sobre o que foi feito com o Arduino

\begin{subsection}{GPIO}
Para implementar o controle por IR usando a Beagle Bone Black, o uso do GPIO e de 
extrema importancia, como no arduino a Beagle Bone possui pinos de entrada e sai
da para funcoes diversas, coisa que o Raspberry nao possui muitos. GPIO significa 
\textit{General Pourpose Input/Output} ou Entrada/Saida de Proposito Geral, logo 
pode ser usado da forma mais conveniente ao desenvolvedor, e possivel controlar a 
tensao de saida, pegar feedback de sensores digitais e analogicos e muitas outras 
funcionalidades.
De acordo com o datasheet \cite{am335x}, o processador possui 128 pinos de GPIO 
divididos em 4 modulos GPIO, com 32 pinos cada, mas o mapeamento dos pinos do 
processador para os pinos de saida da Beagle Bone nao e exatamente igual a 
disposicao no processador, logo e necessario saber como estao dispostos os pinos 
na placa.

\begin{figure}[!h]
        \centering
        \includegraphics[width=\textwidth]{Figures/BBBp8}
        \caption{Mapeamento de Pinos do Header P8 da Beaglebone}
        \label{fig:BBBp8}
\end{figure}

\begin{figure}[!h]
        \centering
        \includegraphics[width=\textwidth]{Figures/BBBp9}
        \caption{Mapeamento de Pinos do Header P9 da Beaglebone}
        \label{fig:BBBp9}
\end{figure}

Entender o mapeamento correto dos pinos e crucial para conseguir alguma saida 
valida dos pinos da placa, ja que o objetivo nao e prototipar a partir do 
processador, e sim usar a placa de desenvolvimento a qual possui pinos mais 
acessiveis. Ao observar \ref{ig:BBBp8} e \ref{fig:BBBp9} pode se entender esse 
mapeamento.
Existem 3 formas de se acessar e controlar os pinos de GPIO, a primeira e
atraves da IDE web que vem instalada no Angstrom de fabrica, mas como o OS foi 
trocado pelo debian essa opcao nao e viavel. Outra forma, a mais complexa, e
iniciar o modulo e atribuir valores atraves de registradores, processo tal e
explicado no datasheet \cite{am335x}, mas despenderia muito tempo e seria pouco
portavel. A ultima solucao foi introduzida com o kernel 3.8.x do linux embarcado,
acessando as interfaces GPIO atraves do kernel, basicamente atribuindo valores a
arquivos, tal processo so pode ser executado como root, entao deve se conhecer
bem o que esta fazendo antes de executar tais comandos.

\begin{lstlisting}[language=bash]
echo 51 > /sys/class/gpio/export 
\end{lstlisting}

Os arquivos de Configuracao do GPIO pelo kernel estao localizados em
\textit{/sys/class/gpio} e o arquivo export inicializa o pino para uso. ao
modificar tal arquivo uma pasta para o pino sera criada, dentro da pasta estarao
arquivos necessarios para a configuracao do pino, so e necessario o uso de dois
arquivos desses para a tarefa de piscar um led IR, os arquivos direction e
value.

\begin{lstlisting}[language=bash]
echo in > /sys/class/gpio/gpiochip51/direction
echo 1 > /sys/class/gpio/gpiochip51/value
\end{lstlisting}

Os comandos listados acima sao o suficiente para acender um led conectado ao
pino 51, ou pino 16 do header p9.

\end{subsection}
%END GPIO
\end{section}
%%% EOF %%%

\begin{section}{Dificuldades e Soluções}
\begin{enumerate}
\item O Ångström é o sistema operacional de fábrica da BeagleBone Black, %$^{\scriptsize{\textregistered}}$, 
bastante referenciado em fóruns e candidato 
principal para ser a base do projeto. Entretanto, o sistema e a nomenclatura de 
pacotes não correspondiam com os usados nas distribuições Debian, o que 
impossibilitava a instalação das dependências necessárias para o uso das 
ferramentas de processamento de voz. Além disso, o Ångström também consumia 
muito espaço de armazenamento na \textit{flash}, ocupando sozinho 1.6~GB de 2~GB 
por conta de sua interface gráfica.

A opção seguinte foi o Ubuntu, pois a similaridade do sistema de pacotes
\texttt{apt-get} com a distribuição \textit{desktop} tornaria a integração mais
fácil. Porém, a instalação da versão 14.04 também ocupava espaço demais na
memória \textit{flash}: aproximadamente 1.2~GB. Além do problema de espaço,
outra dificuldade foi a conexão com a Internet, já que o acesso convencional ao
repositório de pacotes não funcionava. 

A solução veio com a instalação de um terceiro e último sistema operacional, o 
Debian 7.8 wheezy. Este se mostrou muito mais leve e ``enxuto'' em sua versão 
\textit{minimal}, ocupando menos de 500~MB da memória. Além disso, todos os 
pacotes necessários para conexão com a Internet funcionaram perfeitamente.

\item A BeagleBone Black não possui 
saída de áudio nativa, tampouco conectores do tipo \textit{audio jack}. No 
Debian, a saída padrão de áudio é pelo conector HDMI, mas pode ser substituída 
pelo USB mediante modificações em parâmetros do \textit{kernel}. O modo mais 
fácil, considerando que redirecionar a saída do eSpeak para um GPIO seria muito 
trabalhoso, seria conectar um alto-falante USB à BeagleBone Black.
Em se tratando de um protótipo, um 
\textit{headphone} faz o papel de um alto-falante que deve consumir pouca 
energia e ter um tamanho limitado. Foi-se cogitada a construção de um circuito 
com um amplificador LM386 para o \textit{speaker}, porém a obtenção de um D/A 
PCM2707 não custaria menos de US\$ 15.

\item A BeagleBone Black não possui 
conexão \textit{wifi}. Além da dificuldade em atualizar o \textit{kernel} pra 
receber um \textit{shield/cape}, o mesmo teria de ser conectado na  porta USB, 
a qual já estaria sendo usada pelo alto-falante. Portanto, a solução mais fácil 
foi conectar um roteador \textit{wifi} à porta Ethernet da BBB através 
de um cabo UTP.

\item O código criado para o Arduino faz um \textit{dump} da informação captada
pelo \textit{photosensor}, verificando o tempo que ele passa ligado e desligado
e salvando várias medidas de tempo numa matriz de inteiros, o que deixa o
armazenamento dessa informação pouco viável. Após traduzir o código para que
seja executado na BBB, o ideal seria converter os valores de tempo para um
\textit{array} de bits (``110101010'', por exemplo) para que fosse mais fácil
salvar no banco de dados. Isso já funciona, porém somente para o protocolo
RC-6.

\item A função \texttt{mysql\_query()} recebe uma \textit{string} contendo o
comando SQL para acessar o banco de dados MySQL. Caso se queira editar o valor
de um atributo numa determinada tabela, por exemplo, basta passar o valor e o
atributo como parâmetros para a função, o que exige que as \textit{strings}
sejam manipuladas constantemente a fim de tornar as requisições automáticas.
Para que não se utilize mais espaços de memória do que necessário, optou-se pela
alocação dinâmica através da função \texttt{malloc()}, auxiliada pela função
\texttt{sprintf()}, a qual é responsável pela junção de \textit{strings}. O
código ainda está sob revisão, já que diversas falhas de segmentação vêm
ocorrendo devido à erros no gerenciamento de memória. Além disso, o custo
computacional provocado pelas diversas \textit{queries} no banco ainda não pode
ser previsto. Essa previsão é muito importante visto que, em uma futura
utilização de um servidor Apache para acesso remoto de qualquer lugar via
cliente PHP, por exemplo, o efeito \textit{snowball} pode surgir como uma
consequência negativa.

\item Como explicado na seção~\ref{sec:rev_th}, um bit é representado por duas
partes, sendo uma metade nível baixo e a outra nível alto. Para o RC-6, cada 
nível ocorre num intervalo de 16 ciclos (ou 32 ciclos para no caso do protocolo
RC-5), sendo o nível alto gerado pelo protocolo por modulação PWM com
\textit{duty cycle} mínimo de 25\% do período do ciclo, tal como o mostrado na
Figura~\ref{fig:bits}.

\begin{minipage}{\linewidth}
	\centering
	\includegraphics[width=.85\textwidth]{Figures/Bits}
	\captionof{figure}{Processo de geração de cada bit}
	\label{fig:bits}
\end{minipage}

Porém, a BeagleBone Black leva um tempo de 42~$\mu$s para escrever HIGH no pino,
isto é, para gerar a parte ativa do PWM, a plataforma responde com um tempo 
maior do que o próprio ciclo, o qual demora 27.6~$\mu$s aproximadamente.
Levando-se em conta o tempo que a BeagleBone leva para escrever (chamado
de $t_{set}$), de acordo com o esquema mostrado na Figura~\ref{fig:ciclo_pwm},
a duração do bit seria de 111,6~$\mu$s.

\begin{minipage}{\linewidth}
	\centering
	\includegraphics[width=.65\textwidth]{Figures/Ciclo_PWM}
	\captionof{figure}{Ciclo com PWM na BeagleBone Black}
	\label{fig:ciclo_pwm}
\end{minipage}

Logo, este novo tempo de ciclo ir\'{a} afetar diretamente na aquisiç\~{a}o dos dados,
pois reduzir\'{a} a frequ\^{e}ncia de amostragem e n\~{a}o ser\'{a} mais poss\'{i}vel
transmitir os comandos em infravermelho, fazendo uma conta de quanto ir\'{a} impactar,
tem se que:
\begin{equation}
	1 \ s \rightarrow 36k \ valores \rightarrow 27 \ \mu s/valor \notag
\end{equation}
\begin{equation}
	1 \ s \rightarrow n \ valores \rightarrow 111.6 \ \mu s/valor \notag
\end{equation}

Resolvendo a regra de 3 inversa, tem se:
\begin{equation}
	n \approx 8.96k \rightarrow f_{coding} = 8.96 \ kHz \notag
\end{equation}
\begin{equation}
	\frac{f_s}{f_{coding}} = \frac{36k}{8.96k} \approx 4 \notag 
\end{equation}

Com isso pode se observar que a frequ\^{e}ncia de amostragem seria 4 vezes menor
que a desejada. 

%Para combater este problema, foi necess\'{a}rio abrir m\~{a}o do PWM e reajustar
%como cada n\'{i}vel seria gerado, ent\~{a}o o n\'{i}vel alto (antes com PWM) passou a ser
%nada mais que o pino ativo pelo tempo de 1 ciclo ($t_{ciclo} = 27.6 \ \mu s$).
%
%\begin{minipage}{\linewidth}
%	\centering
%	\includegraphics[width=.45\textwidth]{Figures/Bit_noPWM}
%	\captionof{figure}{N\'{i}vel alto sem o PWM}
%	\label{fig:bit_nopwm}
%\end{minipage}
%
%\begin{minipage}{\linewidth}
%	\centering
%	\includegraphics[width=.85\textwidth]{Figures/Bit0_Coding}
%	\captionof{figure}{Timeline do bit 0 na BeagleBone Black}
%	\label{fig:bit0_coding}
%\end{minipage}


%que usar diversas vezes alocaç\~{o}es de mem\'{o}ria (\textit{*malloc()}) e
%\textit{sprintf()}s, tornando o c\'{o}digo, em mais espec\'{i}fico o
%gerenciamento dos campos da mem\'{o}ria, ca\'{o}tico, apresentando algumas vezes
%falha de segmentaç\~{a}o. Posteriormente, com a adiç\~{a}o de outros aparelhos e
%mais tabelas, estas queries ficaram cada vez mais recorrentes e mais falhas
%poderam acontecer. 

%Al\'{e}m disso, por estarmos acessando o MySQL por meio de uma outra linguagem (no caso C), n\~{a}o podemos prever 
%agora poss\'{i}veis custos computacionais que essas diversas e constantes queries poder\~{a}o gerar nas threads 
%dentro do BeagleBone Black\textregistered. Numa poss\'{i}vel e vindoura utilizaç\~{a}o de um servidor Apache com o 
%PHP essa comunicaç\~{a}o adicional e constante poder\'{a} resultar em significante custo computacional tornando-se um 
%efeito \textit{snowball}, bola de neve.
\end{enumerate}
\end{section}
%%% EOF %%%

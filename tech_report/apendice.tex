% Pedro
\begin{section}{Codigos LAMP}
Com a sensível complexidade dos comandos usados para a comunicação com a TV,
devido ao número de campos presente em cada comando e a diferença existente
entre cada campo, bem como evitar possíveis problemas de escalabilidade quando o
sistema evoluir para o controle de diversos equipamentos eletrônicos, adotamos
um banco de dados para armazenar todas essas informações quanto aos aparelhos e
seus comandos.

Além disso, visando uma integração maior do sistema implementado no BeagleBone
Black$^{\small{\textregistered}}$, com as interfaces disponíveis ao usuário e
aos desenvolvedores como a web, a adoção de um servidor Apache e PHP foi
necessária. Essa integração se dá pela criação de uma página web onde serão
armazenados dados provenientes das interação do sistema, por exemplo, caso o
usuário tenha ligado a TV, aumentado o volume, mudado de canal todas essas
informação podem ir para um log de uma página web em que pode ser acessado pelo
desenvolvedor para investigar a performance do sistema. Além do log de comandos
executados pelo usuário, podemos guardar erros cometidos pelo Julius, ou eSpeak
ou ainda falha no envio do comando para o aparelho eletrônico, em casos mais
específicos o usuário poderá até ligar aparelhos remotamente ou o desenvolvedor
avaliar o desempenho do sistema e identificando problemas antes de uma visita
técnica. 

Para integrar todos estes recursos é necessário um sistema operacional, que no
nosso caso foi usado um Linux Debian, configurando assim o servidor LAMP (Linux,
Apache HTTP Server, MySQL e PHP).

Depois de instalar as dependências e configurar o Linux, Apache, MySQL e PHP,
temos que acessar e comunicar com o MySQL por intermédio da linguagem C, para
tal a biblioteca $my\_sql.h$ é usada. No código em C para a comunicação temos 9
funções além da \textit{main}, sendo elas mostradas na Lista~\ref{lst:dbphi0}.

% Code
\lstinputlisting[style=code, language=c, firstline=9, lastline=24,
caption={Functions Definitions}, label={lst:dbphi0}]
{codes/db_phi.c}

Aqui detalhamos o escopo de todas as funções sendo usadas e a \textit{main()},
onde estamos conectando no banco de dados (\textit{$mysql\_init()$}), criando um
banco chamado \textit{y} com o usu\'{a}rio \textit{root}
(\textit{$create\_db()$}). Depois a tabela chamada \textit{tv}
(\textit{$create\_table()$}) é criada e logo após os atributos estão sendo
inseridos (\textit{$insert\_table()$}). Com \textit{$insert\_element()$}
atribuimos um valor a um atributo específico e usamos \textit{$get\_element()$}
para retirar da tabela o valor de um atributo, que no caso é \textit{volume+} da
marca LG.

% Code
\lstinputlisting[style=code, language=c, firstline=26, lastline=52, 
caption={Main}, label={lst:dbphi1}]
{codes/db_phi.c}

% Code
\lstinputlisting[style=code, language=c, firstline=54, lastline=93, 
caption={Função $get\_element()$}, label={lst:dbphi2}]
{codes/db_phi.c}

Esta função é responsável por fazer a \textit{query} no banco de dados que
retornará o valor do atributo específico que queremos obter.  Ela recebe como
entrada o atributo (\textit{$*column$}), a marca "alvo" (\textit{$*target$}),
pode ser qualquer marca, e a conexão com o MySQL (\textit{$*con$}), com isso
podemos selecionar o atributo \textit{column} onde a marca é igual ao
\textit{alvo} passado à função. Após a montagem da sintaxe da \textit{query},
usamos \textit{$mysql\_fetch\_row()$} para pegarmos todos os valores que
satisfazem a condição exigida por nossa \textit{query}, esta por sua vez retorna
apenas um valor, o qual é retornado pela função.

% Code
\lstinputlisting[style=code, language=c, firstline=95, lastline=118, 
caption={função {\tt insert\_element()}}, label={lst:dbphi3}]
{codes/db_phi.c}

Esta função tem como finalidade inserir o valor de um atributo da tabela, ela
recebe o atributo (\textit{$*column$}), o valor (\textit{$*value$}), a marca
``alvo'' (\textit{$*target$}) e a conexão MySQL (\textit{$*con$}). Ela irá
montar a sintaxe da \textit{query}, onde iremos atualizar a tabela \textit{tv}
atribuindo à coluna \textit{$*column$} o valor \textit{$*value$} onde a marca é
igual ao alvo \textit{$*target$}.

% Code
\lstinputlisting[style=code, language=c, firstline=144, lastline=177, 
caption={função {\tt create\_table()}}, label={lst:dbphi4}]
{codes/db_phi.c}

Esta função tem como finalidade a criação de tabelas, ela recebe
o nome da tabela a ser criada (\textit{$*table$}), o banco de dados aonde ela
será criada (\textit{$*db$}), o usuário (\textit{$*user$}), a senha
desse usuário (\textit{$*pwd$}) e a conexão MySQL (\textit{$*con$}). Ela
irá montar com uma sintaxe pré definida a tabela com os atributos
\textit{marca, volume+, volume-, canal+, canal-, on, off, address}.

% Code
\lstinputlisting[style=code, language=c, firstline=179, lastline=190,
caption={função {\tt create\_db()}}, label={lst:dbphi5}]
{codes/db_phi.c}

Esta função tem como finalidade a criação do banco de dados, ela
recebe o nome do banco a ser criado (\textit{$*name$}), o usuário
(\textit{$*user$}), a senha desse usu\'{a}rio (\textit{$*pwd$}) e a conexão
MySQL (\textit{$*con$}). Ela usa o nome \textit{$*name$} para organizar a
sintaxe que cria o banco.

% Code
\lstinputlisting[style=code, language=c, firstline=192, lastline=196, 
caption={função {\tt finish\_with\_error()}}, label={lst:dbphi6}]
{codes/db_phi.c}

Esta função apenas oferece o erro padrão para caso a conexão MySQL passada seja
executada com erro.Ela recebe a conexão MySQL (\textit{$*con$}).

% Code
\textcolor{red}{*Pedro: escrota essa função handle n gostei elimine*}
Em algumas sintaxes do MySQL os atributos são passados como ``nome'', ou seja,
entre aspas duplas, entretanto para inserir estas aspas duplas em C não
é tão trivial assim caso queiramos automatizar o processo de
adição, portanto, esta função foi criada com a finalidade
específica de adicionar e manipular esta string para que ela saia "string".
Ela recebe apenas a string alvo (no caso \textit{$*user$}, pois o caso onde a
usamos é para garantir acesso a algum usuário ao banco de dados.

\textcolor{red}{*Pedro: ajeita essa função GRANT no .c e inclui ela da forma que
incluí as outras aí em cima*}

\begin{lstlisting}[style=code, language=c, caption={função $grant\_db()$}, label={lst:dbphi8}]
int grant_db(char *user, char *db, MYSQL *con){
    char *grantall = "GRANT ALL ON y.* TO GUEST IDENTIFIED BY ";
	char *flush_command = "FLUSH PRIVILEGES";

	char *user_handle = handle_string(user);

	size_t grant_len = strlen(grantall)+strlen(user_handle);

	char *grant_command = (char *) malloc((grant_len+1)* sizeof (char));

	sprintf(grant_command, "%s%s", grantall,user_handle);

	printf("user_handle = %s\n",user_handle);
	printf("%s\n",grant_command);

	if(mysql_query(con, "GRANT ALL ON y TO GUEST IDENTIFIED BY \"phy_dev\""))
		finish_with_error(con);

	printf("Grant Success!\n");
	
	if(mysql_query(con,"FLUSH PRIVILEGES"))
		finish_with_error(con);

	free(result);
	free(grant_command);	
	exit(0);
}
\end{lstlisting}

Aqui garantimos ao usuário \textit{$*user$} acesso ao banco de dados
\textit{$*db$}, por meio de uma conex\~{a}o MySQL \textit{$*con$}. Nela usamos a
função \textit{$handle\_user()$} para modificar a string do usuário
e posteriormente usá-la para montar a sintaxe da \textit{query}.

\end{section}

% Thiago
\begin{section}{Codigos Arduino/C for IR Tx/Rx}
\textcolor{red}
{*
\large
Thiago: Olha no tex do apendice os exemplos de como os arquivos foram incluídos
antes de copiar todo o código aqui. Ou seja, usa lstinputlisting ao invés de
lstlisting, especifica as linhas. Separa as funções que nem o Pedro fez. Achei
melhor colocar a explicação dentro de comentários dentro do próprio código, do
jeito que estás fazendo. Indentação é um tab de 4 espaços, ajeita.
*}
\begin{lstlisting}[style=code, language=c]
/* C\'{o}digo arduino de decodifica\c{c}\~{a}o de comandos infravermelhos
 *
 * O programa decodifica os comandos enviados por um controle remoto (TV, DVD,
 * Ar condicionado...) recebidos por um receptor IR ligado ao arduino e 
 * redireciona o comando usando um transmissor IR 'imitando' os comandos 
 * decodificados. A decodificação é feita captando a duração em que o LED IR
 * ficou ligado transmitindo ou desligado e armazenando essa informação em uma
 * matriz.
 * */

/* \'{E} necessario usar a leitura direta dos pinos do arduino, ja que a func\~{a}o
 * digitalRead() \'{e} lenta e o timing \'{e} muito importante aqui.
 * */

#include <math.h>
#define IRpin_PIN      PIND
#define IRpin          2

int IRledPin = 13;

// Pulso máximo de 65 milisegundos
#define MAXPULSE 65000

// Se a resolu\c{c}\~{a}o for grande demais o timing n\~{a}o será preciso
#define RESOLUTION 20 

// 100 pares de pulsos armazenados (on-off)
uint16_t pulses[100][2];  // par de pulsos high e low 
uint8_t currentpulse = 0; // index dos pulsos sendo armazenados
int pulsedb[200]; // vetor de pulsos em milisegundos que será usado para 
				  // enviar os comandos

void setup(void) {
		pinMode(IRledPin, OUTPUT);
		Serial.begin(9600);
		Serial.println("Pronto para decodificar IR!");
}

void loop(void) {
		uint16_t highpulse, lowpulse;  
		highpulse = lowpulse = 0; 

		//  IRpin_PIN & (1 << IRpin) = leitura direta do pino 
		while (IRpin_PIN & (1 << IRpin)) {
				// Pino ainda high

				highpulse++;
				delayMicroseconds(RESOLUTION);

				/* Se o pulso for muito longo, ou nada ocorreu ou o c\'{o}digo
				 * terminou. Mostra os tempos de pulso no monitor serial.
				 * */
				if ((highpulse >= MAXPULSE) && (currentpulse != 0)) {
						printpulses();
						currentpulse=0;
						return;
				}
		}
		// Pulso nao foi muito longo, armazena na matriz
		pulses[currentpulse][0] = highpulse;

		// Mesmo que o anterior
		while (! (IRpin_PIN & _BV(IRpin))) {
				// Pino ainda low
				lowpulse++;
				delayMicroseconds(RESOLUTION);
				if ((lowpulse >= MAXPULSE)  && (currentpulse != 0)) {
						printpulses();
						currentpulse=0;
						return;
				}
		}
		pulses[currentpulse][1] = lowpulse;

		/* Armazenando a matriz de duas colunas em um vetor com os valores
		 * alternados de cada coluna para, possivelmente, serem enviados
		 * a um banco de dados.
		 * */
		int i=0;
		for(int j=0; j<100; j++){
				pulsedb[i] = pulses[j][0]*RESOLUTION;
				i+=2; 
		}
		i=0;
		for(int j=0; j<100; j++){
				pulsedb[i+1] = pulses[j][1]*RESOLUTION;
				i+=2; 
		}

		// Pulso lido corretamente. 
		currentpulse++;

}

// Fun\c{c}\~{a}o para mostrar o tempo dos pulsos no monitor serial
void printpulses(void) {
		Serial.println("\n\r\n\rRecebido: \n\rOFF \tON");
		for (uint8_t i = 0; i < currentpulse; i++) {
				Serial.print(pulses[i][0] * RESOLUTION, DEC);
				Serial.print(" usec, ");
				Serial.print(pulses[i][1] * RESOLUTION, DEC);
				Serial.print(" usec\t");
		}

		delay(1000);
		// Chama a fun\c{c}\~{a}o que manda o comando pelo led IR
		SendCommand(currentpulse);
}

/* Esse procedimento manda um pulso de 38KHz para o IRledPin durande alguns 
 * microsegundos para reproduzir o comando decodificado (PWM).
 * */
void pulseIR(long microsecs) {

		cli();  // Desliga interrup\c{c}\~{o}es de background

		while (microsecs > 0) {
				// 38 kHz \'{e} aproximadamente 13 microsegundos high e 13 microsegundos low
				digitalWrite(IRledPin, HIGH);  // digitalWrite dura 3 microsegundos
				delayMicroseconds(10);         // esperar 10 microsegundos
				digitalWrite(IRledPin, LOW);   // 3 microsegundos
				delayMicroseconds(10);         // espeera mais 10 microsegundos

				// ent\~{a}o diminuímos 26 microsegundos do pulso
				microsecs -= 26;
		}

		sei();  // Liga as interrup\c{c}\~{o}es
}

/* Fun\c{c}\~{a}o que reproduz o comando no led IR utilizando a matriz de microsegundos
 * 'on' e 'off'
 */
void SendCommand(uint8_t cp) {
		for (uint8_t i = 0; i < cp; i++){
				delayMicroseconds((pulses[i][0] * RESOLUTION)); // off
				pulseIR((pulses[i][1] * RESOLUTION));           // on
		}
		Serial.println("Comando enviado!");
}
\end{lstlisting}
\end{section}

% cassio
\begin{section}{Codigo Arduino Analisador de Onda Quadrada}
\lstinputlisting[style=code, language=matlab, firstline=4, lastline=62]
{codes/myanalyze.m}
\end{section}
%%% EOF %%%

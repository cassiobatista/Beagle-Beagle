\begin{section}{Pedro: Codigos LAMP}
\end{section}

Com a sens\'{i}vel complexidade dos comandos usados para a comunica\c{a}\~ {a}o
com a TV, devido ao n\'{u}mero de campos presente em cada comando e a
diferen\c{c}a existente entre cada campo, bem como evitar poss\'{i}veis
problemas de escalabilidade quando o sistema evoluir para o controle de diversos
equipamentos eletr\^{o}nicos, adotamos um banco de dados para armazenar todas
essas informa\c{c}\~{o}es quanto aos aparelhos e seus comandos.

Al\'{e}m disso, visando uma integra\c{c}\~{a}o maior do sistema implementado no
BeagleBone Black\textregistered, com as interfaces dispon\'{i}veis ao
usu\'{a}rio e aos desenvolvedores como a web, a ado\c{c}ao de um servidor Apache
e PHP foi necess\'{a}ria. Essa integra\c{c}\~{a}o se d\`{a} pela cria\c{c}\~{a}o
de uma p\'{a}gina web onde ser\~{a}o armazenados dados provenientes das
intera\c{c}\~{o}es do sistema, por exemplo, caso o usu\'{a}rio tenha ligado a
TV, aumentado o volume, mudado de canal todas essas informa\c{c}\~{o}es podem ir
para um log de uma p\'{a}gina web em que pode ser acessado pelo desenvolvedor
para investigar a performance do sistema. Al\'{e}m do log de comandos executados
pelo usu\'{a}rio, podemos guardar erros cometidos pelo Julius, ou eSpeak ou
ainda falha no envio do comando para o aparelho eletr\^{o}nico, em casos mais
espec\'{i}ficos o usu\'{a}rio poder\'{a} at\'{e} ligar aparelhos remotamente ou
o desenvolvedor avaliar o desempenho do sistema e identificando problemas antes
de uma visita t\'{e}cnica. 

Para integrar todos estes recursos \'{e} necess\'{a}rio um sistema operacional,
que no nosso caso foi usado um Linux Debian, configurando assim o servidor LAMP
(Linux, Apache HTTP Server, MySQL e PHP).

Depois de instalar as depend\^{e}ncias e configurar o Linux, Apache, MySQL e
PHP, temos que acessar e comunicar com o MySQL por interm\'{e}dio da linguagem
C, para tal a biblioteca $my\_sql.h$ \'{e} usada. No c\'{o}digo em C para a
comunica\c{c}\~{a}o temos 9 fun\c{c}\~{o}es al\'{e}m da \textit{main}, sendo
elas: \textit{$get\_element()$, $insert\_element()$, $insert\_table()$},
\textit{$finish\_with\_error(), *handle\_string(), create\_db()$},
\textit{$grant\_db(), create\_table()$}.

\begin{lstlisting}[language=c, caption={db on c general structure}, label={lst:dbphi1}, basicstyle=\ttfamily\scriptsize]
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <my_global.h>
#include <mysql.h>

#define DEBUG 0

/* Get element from table and store in an INT variable, pass the column and the row ("volume+","sony",con) */
int get_element(char *column, char *target, MYSQL *con);
/* Insert element in the table, pass the column and and the row ("volume+","11111","lg", con) */
int insert_element(char *column, char *value, char *target, MYSQL *con); 
/* Insert row in the table, pass the column and the field ("marca","lg",con) */
int insert_table(char *column, char *field ,MYSQL *con); 
/* Default exit if mysql_query returns an error */
void finish_with_error(MYSQL *con);
/* Function that transforms string user into "user", not used now (was used by grant_db to grant database access to a user) */
char *handle_string(char *user);
/* Creates the database, pass the name, user accessing and pwd of the user ("phi_project","root","pwd",con) */
int create_db(char *name, char *user, char *pwd, MYSQL *con);
/* Grant database access to a specific user, not being used right now due to seg fault. */
int grant_db(char *user, char *db, MYSQL *con);
/* Create a table in the database, right now is a default table defined by the strings on the function */
int create_table(char *table, char *db, char *user, char *pwd, MYSQL *con);

int main(int argc, char **argv)
{
	MYSQL *con = mysql_init(NULL);
	int i =0;

	if(con == NULL){
		fprintf(stderr, "%s\n", mysql_error(con));
		exit(1);
	}

	/* Executar apenas uma vez para criar o db */
	create_db("y","root","pwd",con);
	
	create_table("tv","y","root","pwd",con);
	insert_table("marca","sony",con);
	insert_table("marca","lg",con);
	insert_table("marca","phillips",con);
	insert_table("marca","samsung",con);
	insert_element("volume+","11101","lg",con);
	int vol_lg = get_element("volume+","lg",con);
	insert_element("on","100000111","sony",con);
	int on_sony = get_element("on","sony",con);

	printf("volume+ of lg = %d\non of sony = %d\n", vol_lg,on_sony);
	mysql_close(con);
	exit(0);
}
\end{lstlisting}

Aqui detalhamos o escopo de todas as fun\c{c}\~{o}es sendo usadas e a
\textit{main()}, onde estamos conectando no banco de dados
(\textit{$mysql\_init()$}), criando um banco chamado \textit{y} com o
usu\'{a}rio \textit{root} (\textit{$create\_db()$}). Depois a tabela chamada
\textit{tv} (\textit{$create\_table()$}) \'{e} criada e logo ap\'{o} os
atributos est\~{a}o sendo inseridos (\textit{$insert\_table()$}). Com
\textit{$insert\_element()$} atribuimos um valor a um atributo espec\'{i}fico e
usamos \textit{$get\_element()$} para retirar da tabela o valor de um atributo,
que no caso \'{e} \textit{volume+} da marca lg.

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $get\_element()$}, label={lst:dbphi2}]
int get_element(char *column, char *target, MYSQL *con)
{
	char *cmd_arr[] = {"SELECT `", column, "` FROM tv WHERE marca='", target, "'"};
	char *str_value;

	int i;
	size_t len = 0;
	for(i=0; i<sizeof(cmd_arr)/(sizeof(char)*8); i++)
		len+= strlen(cmd_arr[i]);

	char *cmd = (char *) malloc ((len+1) * sizeof(char));
	for(i=0; i<sizeof(cmd_arr)/(sizeof(char)*8); i++)
		sprintf(cmd, "%s%s", cmd, cmd_arr[i]);

	if(DEBUG)
		printf("%s\n", cmd);

	if(mysql_query(con, cmd))
		finish_with_error(con);
   
	MYSQL_RES *result = mysql_store_result(con);
	if(result == NULL)
		finish_with_error(con);

	MYSQL_FIELD *field;
	int num_fields = mysql_num_fields(result);
	MYSQL_ROW row;
	
	while((row = mysql_fetch_row(result)))
		str_value = (row[0] ? row[0] : "NULL");

	mysql_free_result(result);

	free(cmd);
	return atoi(str_value);
}
\end{lstlisting}

Esta fun\c{c}\~{a}o \'{e} respons\'{a}vel por fazer a \textit{query} no banco de
dados que retornar\'{a} o valor do atributo espec\'{i}fico que queremos obter.
Ela recebe como entrada o atributo (\textit{$*column$}), a marca "alvo"
(\textit{$*target$}), pode ser qualquer marca, e a conex\~{a}o com o MySQL
(\textit{$*con$}), com isso podemos selecionar o atributo \textit{column} onde a
marca \'{e} igual ao \textit{alvo} passado \`{a} fun\c{c}\~{a}o. Ap\'{o}s a
montagem da sintaxe da \textit{query}, usamos \textit{$mysql\_fetch\_row()$}
para pegarmos todos os valores que satisfazem a condi\c{c}\~{a}o exigida por
nossa \textit{query}, esta por sua vez retorna apenas um valor, o qual \'{e}
retornado pela fun\c{c}\~{a}o.

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $insert\_element()$}, label={lst:dbphi3}]
int insert_element(char *column, char *value, char *target, MYSQL *con)
{
	char *cmd_arr[] = {"UPDATE tv SET `", column ,"`=", value, " WHERE marca='", target, "'"};
	char *cmd = "";

	int i;
	size_t len = 0;
	for(i=0; i<sizeof(cmd_arr)/(sizeof(char)*8); i++)
		len+= strlen(cmd_arr[i]);

	cmd = (char *) malloc ((len+1) * sizeof(char));
	for(i=0; i<sizeof(cmd_arr)/(sizeof(char)*8); i++)
		sprintf(cmd, "%s%s", cmd, cmd_arr[i]);

	if(DEBUG)
		printf("%s\n", cmd);

	if(mysql_query(con, cmd))
		finish_with_error(con);

	free(cmd);
	return 0;
}
\end{lstlisting}

Esta fun\c{c}\~{a}o tem como finalidade inserir o valor de um atributo da
tabela, ela recebe o atributo (\textit{$*column$}), o valor (\textit{$*value$}),
a marca "alvo" (\textit{$*target$}) e a conex\~{a}o MySQL (\textit{$*con$}). Ela
ir\'{a} montar a sintaxe da \textit{query}, onde iremos atualizar a tabela
\textit{tv} atribuindo \`{a} coluna \textit{$*column$} o valor \textit{$*value$}
onde a marca \'{e} igual ao alvo \textit{$*target$}.

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $create\_table()$}, label={lst:dbphi4}]
int create_table(char *table, char *db, char *user, char *pwd, MYSQL *con)
{
	char d_command[22] = "DROP TABLE IF EXISTS ";
	char c_command[13] = "CREATE TABLE ";
	char table1[50] = "(`marca` VARCHAR(40) NOT NULL,`volume+` INT,";
	char table2[50] = "`volume-` INT,`canal+` INT,`canal-` INT,`on` INT,";
	char table3[50] = "`off` INT,`address` INT, UNIQUE (`marca`))";

	size_t create_len = strlen(c_command)+strlen(table)+strlen(table1)+strlen(table2)+strlen(table3);
	size_t drop_len = strlen(d_command)+strlen(table);

	char *drop_command = (char *) malloc ((drop_len+1) * sizeof(char));
	char *create_command = (char*) malloc ((create_len+1) * sizeof(char));

	sprintf(drop_command, "%s%s",d_command, table);
	sprintf(create_command,"%s%s%s%s%s",c_command,table,table1,table2,table3);

	if(mysql_real_connect(con,"localhost",user,pwd,db,0,NULL,0) == NULL)
		finish_with_error(con);

	if(mysql_query(con, drop_command))
		finish_with_error(con);

	if(mysql_query(con,create_command))
		finish_with_error(con);

	if(DEBUG)
		printf("%s\n%s\n",drop_command,create_command);

	free(drop_command);
	free(create_command);
	return 0;
}
\end{lstlisting}

Esta fun\c{c}\~{a}o tem como finalidade a cria\c{c}\~{a}o de tabelas, ela recebe
o nome da tabela a ser criada (\textit{$*table$}), o banco de dados aonde ela
ser\'{a} criada (\textit{$*db$}), o usu\'{a}rio (\textit{$*user$}), a senha
desse usu\'{a}rio (\textit{$*pwd$}) e a conex\~{a}o MySQL (\textit{$*con$}). Ela
ir\'{a} montar com uma sintaxe pr\'{e} definida a tabela com os atributos
\textit{marca, volume+, volume-, canal+, canal-, on, off, address}.

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $create\_db()$}, label={lst:dbphi5}]
int create_db(char *name, char *user, char *pwd,  MYSQL *con)
{
	char *create_command = "CREATE DATABASE ";

	if(mysql_real_connect(con,"localhost",user,pwd,NULL,0,NULL,0) == NULL)
		finish_with_error(con);

	if(mysql_query(con, strcat(create_command, name)))
		finish_with_error(con);

	return 0;
}
\end{lstlisting}

Esta fun\c{c}\~{a}o tem como finalidade a cria\c{c}\~{a}o do banco de dados, ela
recebe o nome do banco a ser criado (\textit{$*name$}), o usu\'{a}rio
(\textit{$*user$}), a senha desse usu\'{a}rio (\textit{$*pwd$}) e a conex\~{a}o
MySQL (\textit{$*con$}). Ela usa o nome \textit{$*name$} para organizar a
sintaxe que cria o banco.

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $finish\_with\_error()$}, label={lst:dbphi6}]
void finish_with_error(MYSQL *con)
{
	fprintf(stderr, "%s\n", mysql_error(con));
	mysql_close(con);
	exit(1);
}
\end{lstlisting}

Esta fun\c{c}\~{a}o apenas oferece o erro padr\~{a}o para caso a conex\~{a}o
MySQL passada seja executada com erro.Ela recebe a conex\~{a}o MySQL
(\textit{$*con$}).

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $handle\_string()$}, label={lst:dbphi7}]
char *handle_string(char *user)
{
	char *old  = user;
	char *handle = "\"";
	char *result;

	result = (char *) malloc (strlen(old)+3 * sizeof(char));
	sprintf(result, "%s%s%s",handle,old,handle);

	printf("%s\n",result);

	return result;
}
\end{lstlisting}

Em algumas sintaxes do MySQL os atributos s\~{a}o passados como "nome", ou seja,
entre aspas duplas, entretanto para inserir estas aspas duplas em C n\~{a}o
\'{e} t\~{a}o trivial assim caso queiramos automatizar o processo de
adi\c{c}\~{a}o, portanto, esta fun\c{c}\~{a}o foi criada com a finalidade
espec\'{i}fica de adicionar e manipular esta string para que ela saia "string".
Ela recebe apenas a string alvo (no caso \textit{$*user$}, pois o caso onde a
usamos \'{e} para garantir acesso a algum usu\'{a}rio ao banco de dados.

\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $grant\_db()$}, label={lst:dbphi8}]
int grant_db(char *user, char *db, MYSQL *con){
    char *grantall = "GRANT ALL ON y.* TO GUEST IDENTIFIED BY ";
	char *flush_command = "FLUSH PRIVILEGES";

	char *user_handle = handle_string(user);

	size_t grant_len = strlen(grantall)+strlen(user_handle);

	char *grant_command = (char *) malloc((grant_len+1)* sizeof (char));

	sprintf(grant_command, "%s%s", grantall,user_handle);

	printf("user_handle = %s\n",user_handle);
	printf("%s\n",grant_command);

	if(mysql_query(con, "GRANT ALL ON y TO GUEST IDENTIFIED BY \"phy_dev\""))
		finish_with_error(con);

	printf("Grant Success!\n");
	
	if(mysql_query(con,"FLUSH PRIVILEGES"))
		finish_with_error(con);

	free(result);
	free(grant_command);	
	exit(0);
}
\end{lstlisting}

Aqui garantimos ao usu\'{a}rio \textit{$*user$} acesso ao banco de dados
\textit{$*db$}, por meio de uma conex\~{a}o MySQL \textit{$*con$}. Nela usamos a
fun\c{c}\~{a}o \textit{$handle\_user()$} para modificar a string do usu\'{a}rio
e posteriormente us\'{a}-la para montar a sintaxe da \textit{query}.

\begin{section}{Thiago: Codigos Arduino/C for IR Tx/Rx}
\begin{lstlisting}[language=c, caption={fun\c{c}\~{a}o $grant\_db()$}, label={lst:dbphi8}]
/* Código arduino de decodificação de comandos infravermelhos
 *
 * O programa decodifica os comandos enviados por um controle remoto (TV, DVD,
 * Ar condicionado...) recebidos por um receptor IR ligado ao arduino e 
 * redireciona o comando usando um transmissor IR 'imitando' os comandos 
 * decodificados. A decodificação é feita captando a duração em que o LED IR
 * ficou ligado transmitindo ou desligado e armazenando essa informação em uma
 * matriz.
 * */

/* É necessario usar a leitura direta dos pinos do arduino, ja que a funcão
 * digitalRead() é lenta e o timing é muito importante aqui.
 * */

#include <math.h>
#define IRpin_PIN      PIND
#define IRpin          2

int IRledPin = 13;

// Pulso máximo de 65 milisegundos
#define MAXPULSE 65000

// Se a resolução for grande demais o timing não será preciso
#define RESOLUTION 20 

// 100 pares de pulsos armazenados (on-off)
uint16_t pulses[100][2];  // par de pulsos high e low 
uint8_t currentpulse = 0; // index dos pulsos sendo armazenados
int pulsedb[200]; // vetor de pulsos em milisegundos que será usado para 
				  // enviar os comandos

void setup(void) {
		pinMode(IRledPin, OUTPUT);
		Serial.begin(9600);
		Serial.println("Pronto para decodificar IR!");
}

void loop(void) {
		uint16_t highpulse, lowpulse;  
		highpulse = lowpulse = 0; 

		//  IRpin_PIN & (1 << IRpin) = leitura direta do pino 
		while (IRpin_PIN & (1 << IRpin)) {
				// Pino ainda high

				highpulse++;
				delayMicroseconds(RESOLUTION);

				/* Se o pulso for muito longo, ou nada ocorreu ou o código
				 * terminou. Mostra os tempos de pulso no monitor serial.
				 * */
				if ((highpulse >= MAXPULSE) && (currentpulse != 0)) {
						printpulses();
						currentpulse=0;
						return;
				}
		}
		// Pulso nao foi muito longo, armazena na matriz
		pulses[currentpulse][0] = highpulse;

		// Mesmo que o anterior
		while (! (IRpin_PIN & _BV(IRpin))) {
				// Pino ainda low
				lowpulse++;
				delayMicroseconds(RESOLUTION);
				if ((lowpulse >= MAXPULSE)  && (currentpulse != 0)) {
						printpulses();
						currentpulse=0;
						return;
				}
		}
		pulses[currentpulse][1] = lowpulse;

		/* Armazenando a matriz de duas colunas em um vetor com os valores
		 * alternados de cada coluna para, possivelmente, serem enviados
		 * a um banco de dados.
		 * */
		int i=0;
		for(int j=0; j<100; j++){
				pulsedb[i] = pulses[j][0]*RESOLUTION;
				i+=2; 
		}
		i=0;
		for(int j=0; j<100; j++){
				pulsedb[i+1] = pulses[j][1]*RESOLUTION;
				i+=2; 
		}

		// Pulso lido corretamente. 
		currentpulse++;

}

// Função para mostrar o tempo dos pulsos no monitor serial
void printpulses(void) {
		Serial.println("\n\r\n\rRecebido: \n\rOFF \tON");
		for (uint8_t i = 0; i < currentpulse; i++) {
				Serial.print(pulses[i][0] * RESOLUTION, DEC);
				Serial.print(" usec, ");
				Serial.print(pulses[i][1] * RESOLUTION, DEC);
				Serial.print(" usec\t");
		}

		delay(1000);
		// Chama a função que manda o comando pelo led IR
		SendCommand(currentpulse);
}

/* Esse procedimento manda um pulso de 38KHz para o IRledPin durande alguns 
 * microsegundos para reproduzir o comando decodificado (PWM).
 * */
void pulseIR(long microsecs) {

		cli();  // Desliga interrupções de background

		while (microsecs > 0) {
				// 38 kHz é aproximadamente 13 microsegundos high e 13 microsegundos low
				digitalWrite(IRledPin, HIGH);  // digitalWrite dura 3 microsegundos
				delayMicroseconds(10);         // esperar 10 microsegundos
				digitalWrite(IRledPin, LOW);   // 3 microsegundos
				delayMicroseconds(10);         // espeera mais 10 microsegundos

				// então diminuímos 26 microsegundos do pulso
				microsecs -= 26;
		}

		sei();  // Liga as interrupções
}

/* Função que reproduz o comando no led IR utilizando a matriz de microsegundos
 * 'on' e 'off'
 */
void SendCommand(uint8_t cp) {
		for (uint8_t i = 0; i < cp; i++){
				delayMicroseconds((pulses[i][0] * RESOLUTION)); // off
				pulseIR((pulses[i][1] * RESOLUTION));           // on
		}
		Serial.println("Comando enviado!");
}
\end{lstlisting}
\end{section}
%%% EOF %%%
